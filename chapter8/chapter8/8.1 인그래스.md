### 인그레스(Ingress)란 무엇인가?

  쿠버네티스 클러스터 외부의 요청을 내부의 서비스(Service)로 연결해주는 관문(Gateway) 역할을 하는 API 객체입니다. 주로 HTTP와 HTTPS 라우팅을 관리하기 위해 사용됩니다.

  NodePort나 LoadBalancer 타입의 서비스만으로도 서비스를 외부에 노출할 수는 있지만, 다음과 같은 한계가 있습니다.
   * NodePort: 클러스터의 모든 노드(Node)에 특정 포트가 열리며, http://<노드IP>:<포트>와 같이 예쁘지 않은 주소로 접근해야 합니다.
   * LoadBalancer: 서비스마다 별도의 외부 로드밸런서(보통 유료)가 할당되어 비용 부담이 큽니다.

  인그레스는 이러한 문제들을 해결합니다.
   * 단일 진입점(Single Entrypoint): 단 하나의 외부 IP 주소로 여러 서비스를 노출할 수 있습니다.
   * URL 라우팅: example.com/api는 A 서비스로, example.com/web은 B 서비스로 보내는 등 경로 기반
     라우팅(Path-based routing)이 가능합니다.
   * 가상 호스팅: aaa.example.com은 A 서비스로, bbb.example.com은 B 서비스로 보내는 등 호스트 기반
     라우팅(Host-based routing)이 가능합니다.
   * TLS/SSL 처리: HTTPS를 위한 TLS 인증서 관리 및 적용(TLS Termination)을 인그레스에서 중앙 처리할 수 있습니다.

  #### 인그레스의 핵심 구성 요소

   1. 인그레스 리소스 (Ingress Resource): 사용자가 작성하는 YAML 파일입니다. "어떤 주소로 들어온 요청을 어떤 서비스로 보낼지"에 대한 라우팅 규칙을 정의합니다.
   2. 인그레스 컨트롤러 (Ingress Controller): 실제 작업을 수행하는 두뇌입니다. 클러스터 내에서 실행되는 파드(Pod)로, 인그레스 리소스에 정의된 규칙을 읽어서 외부 요청을 실제 서비스로 전달하는 리버스 프록시(Reverse Proxy) 역할을 합니다. 인그레스 컨트롤러가 설치되어 있지 않으면 인그레스 리소스는 아무 동작도 하지 않습니다. (예: Nginx, Traefik, HAProxy 등)

  ---

  인그레스 예제: 경로 기반 라우팅

  목표:
   1. 인그레스 컨트롤러(Nginx)를 설치합니다.
   2. /apple 경로로 요청이 오면 "사과 앱"으로, /banana 경로로 오면 "바나나 앱"으로 연결되도록 설정합니다.
   3. TLS를 적용하여 HTTPS 통신을 구성합니다.

  ---

  1단계: 인그레스 컨트롤러 설치 (가장 중요)

  클러스터에 인그레스 컨트롤러가 없다면 먼저 설치해야 합니다. 가장 널리 쓰이는 NGINX 인그레스 컨트롤러를 설치하겠습니다.

```
# NGINX Ingress Controller 공식 설치 명령
kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.10.1/deploy/static/provider/cloud/deploy.yaml
```     
  설치 확인: ingress-nginx 네임스페이스에 컨트롤러 파드가 Running 상태가 될 때까지 몇 분 정도 기다립니다.
```
kubectl get pods --namespace=ingress-nginx -w
```

AWS 일 경우 EXTERNAL-IP에 LoadBalancer 서버의 주소 출력됨 
```
kubectl get service --namespace=ingress-nginx
NAME                                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
ingress-nginx-controller             LoadBalancer   10.104.38.219   <pending>     80:31798/TCP,443:31356/TCP   10m
ingress-nginx-controller-admission   ClusterIP      10.98.41.251    <none>        443/TCP                      10m
```


온프로미스 일 경우 EXTERNAL-IP에 <pending> 출력됨 -> Type:LoadBalancer를  Type:NodePor 로 변경해야 함 
```
kubectl get service --namespace=ingress-nginx
NAME                                 TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE
ingress-nginx-controller             LoadBalancer   10.104.38.219   <pending>     80:31798/TCP,443:31356/TCP   10m
ingress-nginx-controller-admission   ClusterIP      10.98.41.251    <none>        443/TCP                      10m
```

```
kubectl edit svc ingress-nginx-controller -n ingress-nginx
...
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  sessionAffinity: None
  type: LoadBalancer # <- NodePort 로 변경하고 저장함 
status:
  loadBalancer: {}
```
  ---

  2단계: 백엔드 애플리케이션 배포

  라우팅을 테스트할 두 개의 간단한 웹 애플리케이션(apple-app, banana-app)과 각각을 위한 서비스를 배포합니다.

폴더 구조 
8.1
├── backend
│   ├── Dockerfile
│   ├── build.sh
│   ├── main.py
│   └── requirements.txt
└── backend-apps.yaml

   * `backend-apps.yaml` 파일 작성:
```
vi backend-apps.yaml
# backend-apps.yaml

# 1. Apple 애플리케이션
apiVersion: apps/v1
kind: Deployment
metadata:
  name: apple-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: apple
  template:
    metadata:
      labels:
        app: apple
    spec:
      containers:
      - name: apple-container
        image: masungil/http-echo
        ports:
        - containerPort: 8000
        env:
        - name: ECHO_TEXT
          value: "이것은 사과 애플리케이션입니다!"
---
apiVersion: v1
kind: Service
metadata:
  name: apple-service
spec:
  selector:
    app: apple
  ports:
  - protocol: TCP
    port: 8000 # Service 포트

---

# 2. Banana 애플리케이션
apiVersion: apps/v1
kind: Deployment
metadata:
  name: banana-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: banana
  template:
    metadata:
      labels:
        app: banana
    spec:
      containers:
      - name: banana-container
        image: hashicorp/http-echo
        ports:
        - containerPort: 8000
        env:
        - name: ECHO_TEXT
          value: "이것은 바나나 애플리케이션입니다!"
---
apiVersion: v1
kind: Service
metadata:
  name: banana-service
spec:
  selector:
    app: banana
  ports:
  - protocol: TCP
    port: 8000 # Service 포트

```
   * FastAPI http-echo 애플리케이션  :
```
# vi main.py
import os
from fastapi import FastAPI, Response

# 애플리케이션 시작 시 환경 변수 'ECHO_TEXT'를 읽어옵니다.
# 환경 변수가 설정되지 않은 경우, 기본 메시지를 사용합니다.
echo_text = os.environ.get("ECHO_TEXT", "ECHO_TEXT environment variable is not set.")

app = FastAPI()

@app.get("/")
def read_root():
    """
    루트 경로로 GET 요청이 오면, 시작 시점에 저장된 echo_text를
    일반 텍스트(plain text)로 응답합니다.
    """
    return Response(content=f"{echo_text}\n", media_type="text/plain; charset=utf-8")

@app.get("/health")
def health_check():
    """
    서비스 상태를 확인하기 위한 헬스 체크 엔드포인트입니다.
    """
    return {"status": "ok"}

```
   * FastAPI http-echo Dockerfile  :
```
# vi Dockerfile
# 1. 베이스 이미지로 공식 Python 이미지를 사용합니다.
FROM python:3.9-slim

# 2. 작업 디렉토리를 /app으로 설정합니다.
WORKDIR /app

# 3. 의존성 파일을 먼저 복사하여 Docker 캐시를 활용합니다.
COPY requirements.txt requirements.txt

# 4. 의존성을 설치합니다.
RUN pip install --no-cache-dir -r requirements.txt

# 5. 애플리케이션 코드를 복사합니다.
COPY main.py main.py

# 6. 컨테이너가 8000번 포트를 리슨하도록 설정합니다.
EXPOSE 8000

# 7. 컨테이너가 시작될 때 실행할 명령어를 정의합니다.
# Uvicorn을 사용하여 FastAPI 앱을 실행합니다.
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]

```

   * FastAPI 패키지 파일 :
```
#vi requirements.txt

fastapi
uvicorn[standard]

```
   * http-echo 이미지 빌드 :
```
cd backend
chmod +x build.sh
./build.sh
```

   * 애플리케이션 배포:
```
kubectl apply -f backend-apps.yaml
```
   * 파드, 서비스, 디플로이먼트 실행 확인 :
```
kubectl get pod,service,deploy -o wide
```

   *  CLUSTER-IP로 서비스 실행 확인 :
```
curl  CLUSTER-IP:8000

```

  ---

  3단계: 인그레스 리소스 생성 및 배포

  이제 /apple과 /banana 경로에 대한 라우팅 규칙을 정의하는 인그레스 리소스를 작성합니다.

   * `my-ingress.yaml` 파일 작성:
```
vi my-ingress.yaml
# my-ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
  annotations:
    # 경로 재작성(Rewrite) 활성화. /apple -> / 로 전달
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  # NGINX Ingress Controller를 사용함을 명시
  kubernetes.io/ingress.class: "nginx"   #이부분 버전 변경으로 위치 변경됨 
  rules:
  - http:
      paths:
      - path: /apple # /apple 경로로 들어오는 요청
        pathType: Prefix
        backend:
          service:
            name: apple-service # apple-service로 전달
            port:
              number: 8000
      - path: /banana # /banana 경로로 들어오는 요청
        pathType: Prefix
        backend:
          service:
            name: banana-service # banana-service로 전달
            port:
              number: 8000
```

       * nginx.ingress.kubernetes.io/rewrite-target: /: 매우 중요한 어노테이션입니다. 만약 이 설정이 없다면, /apple으로 들어온 요청이 apple-service에 그대로 /apple 경로로 전달됩니다. http-echo 앱은 / 경로에만 응답하므로, 이 설정을 통해 앞의 경로 접두사(/apple)를 제거하고 루트(/) 경로로 요청을 보내도록 합니다.

   * 인그레스 리소스 배포:
```  
kubectl apply -f my-ingress.yaml
```
  ---

  4단계: 라우팅 테스트

   * 4-1. 인그레스 외부 IP 주소 확인:
      ingress-nginx 네임스페이스의 서비스 정보를 확인하여 외부 IP(EXTERNAL-IP)를 얻습니다. 클라우드 환경에서는 IP가 할당되기까지 몇 분 걸릴 수 있습니다.
```
kubectl get service --namespace=ingress-nginx
```
      ingress-nginx-controller 서비스의 EXTERNAL-IP를 확인하고, 이 주소를 INGRESS_IP라고 하겠습니다. (만약 pending 상태라면 잠시 기다리세요. 로컬 환경이라면 localhost나 노드 IP를 사용해야 할 수 있습니다.)

   * 4-2. `curl`로 접속 테스트:
      터미널에서 curl 명령어로 각 경로에 접속해봅니다.

   1     # Apple 앱 테스트
   2     curl http://<INGRESS_IP>/apple
   3
   4     # Banana 앱 테스트
   5     curl http://<INGRESS_IP>/banana

   * 예상 결과:
```
# Apple 앱 결과
이것은 사과 애플리케이션입니다!

# Banana 앱 결과
이것은 바나나 애플리케이션입니다!
```
 이 결과가 나왔다면, 인그레스 컨트롤러가 /apple과 /banana 경로에 따라 요청을 올바르게 라우팅한 것입니다.

  ---

  5단계 (심화): TLS 적용하여 HTTPS 통신하기

  이번에는 my-app.com이라는 가상 호스트에 TLS 인증서를 적용하여 HTTPS 통신을 구성해 보겠습니다.

   * 5-1. 테스트용 TLS 인증서 및 Secret 생성:
      my-app.com에 대한 자체 서명 인증서(self-signed certificate)와 개인키를 만들고, 이를 tls-secret이라는 이름의 Secret으로 저장합니다.

```
# 1. 인증서와 개인키 생성
openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
   -keyout tls.key -out tls.crt -subj "/CN=my-app.com"

# 2. 생성된 파일로 TLS Secret 만들기
kubectl create secret tls tls-secret --key tls.key --cert tls.crt

# 3. 임시 파일 삭제
rm tls.key tls.crt
```
   * 5-2. TLS가 적용된 인그레스 YAML 작성 (`my-ingress-tls.yaml`):
      기존 my-ingress.yaml에 tls와 host 섹션을 추가합니다.
```
vi my-ingress-tls.yaml
# my-ingress-tls.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress-tls
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  ingressClassName: "nginx"
  tls: # TLS 설정 추가
  - hosts:
    - my-app.com # 이 호스트 이름에 TLS를 적용
    secretName: tls-secret # 5-1에서 만든 Secret 사용
  rules:
  - host: my-app.com # 호스트 기반 라우팅 규칙
    http:
      paths:
      - path: /apple
        pathType: Prefix
        backend:
          service:
            name: apple-service
            port:
              number: 8000
      - path: /banana
        pathType: Prefix
        backend:
          service:
            name: banana-service
            port:
              number: 8000
```
   * 5-3. TLS 인그레스 배포:
```   
kubectl apply -f my-ingress-tls.yaml
```
   * 5-4. HTTPS 접속 테스트:
      curl의 --resolve 옵션을 사용하여 my-app.com 도메인 요청을 우리의 INGRESS_IP로 보내도록 강제합니다.
  -k 옵션은 자체 서명 인증서의 경고를 무시하는 옵션입니다.
```
#aws 애서 실행 하는 방법 
curl --resolve my-app.com:443:<INGRESS_IP> https://my-app.com/apple -k
curl --resolve my-app.com:443:<INGRESS_IP> https://my-app.com/banana -k

#온프라미스 사설망에서 실행하는 방법
curl --resolve my-app.com:31356:192.168.80.160 https://my-app.com:31356/apple -k
curl --resolve my-app.com:31356:192.168.80.160 https://my-app.com:31356/banana -k
```

#윈도우 hosts 파일에 도메인 추가 
```
192.168.80.160 my-app.com
```
#윈도우에서 브라우저 실행 주소창에 주소 입력 후 확인  
```
https://my-app.com:31356/apple
https://my-app.com:31356/banana
```

  이제 https로 접속해도 이전과 동일한 결과가 나오면 TLS 설정까지 완벽하게 성공한 것입니다.

  리소스 정리
  테스트가 끝났으면 아래 명령어로 모든 리소스를 삭제합니다.
```
kubectl delete -f my-ingress-tls.yaml
kubectl delete secret tls-secret
kubectl delete -f backend-apps.yaml
# 인그레스 컨트롤러 삭제 (더 이상 사용하지 않을 경우)
# kubectl delete -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.10.1/deploy/staticprovider/cloud/deploy.yaml
```


✦ 네, 가비아(Gabia)에서 구매한 도메인을 AWS EC2 서버에 연결하는 표준적인 방법을 단계별로 알려드리겠습니다.

  전체 과정은 크게 3가지로 나뉩니다.
   1. AWS EC2: EC2 인스턴스에 고정 IP(Elastic IP)를 할당합니다.
   2. AWS Route 53: 도메인의 DNS 설정을 관리할 호스팅 영역(Hosted Zone)을 만들고, EC2의 고정 IP를 가리키는 A
      레코드를 생성합니다.
   3. 가비아: 도메인의 네임서버(Name Server)를 가비아의 것이 아닌 AWS Route 53의 네임서버로 변경합니다.

  ---

  1단계: AWS EC2 - 고정 IP 할당 (Elastic IP)

  EC2 인스턴스는 중지했다가 다시 시작하면 Public IP가 변경될 수 있습니다. 도메인이 항상 같은 IP를 가리키게
  하려면 고정 IP인 Elastic IP를 할당해야 합니다.

   1. AWS 콘솔에서 EC2 서비스로 이동합니다.
   2. 왼쪽 메뉴에서 [네트워크 및 보안] -> [탄력적 IP] (Elastic IPs)를 선택합니다.
   3. [탄력적 IP 주소 할당] (Allocate Elastic IP address) 버튼을 클릭하고, 기본값 그대로 둔 채 [할당] 버튼을 누릅니다.
   4. 새로 생성된 IP 주소를 목록에서 선택한 후, [작업] (Actions) 드롭다운 메뉴에서 [탄력적 IP 주소 연결]  (Associate Elastic IP address)을 선택합니다.
   5. [인스턴스]를 선택하고, 연결할 EC2 인스턴스를 목록에서 찾아 선택합니다.
   6. [연결] (Associate) 버튼을 클릭합니다.
   7. 이제 이 할당된 고정 IP 주소를 잘 기록해 둡니다.

  2단계: AWS Route 53 - 호스팅 영역 및 레코드 생성

  Route 53은 AWS의 DNS 서비스입니다. 여기서 도메인과 IP 주소의 연결 규칙(레코드)을 설정합니다.

   1. AWS 콘솔에서 Route 53 서비스로 이동합니다.
   2. 왼쪽 메뉴에서 [호스팅 영역] (Hosted zones)을 선택합니다.
   3. [호스팅 영역 생성] (Create hosted zone) 버튼을 클릭합니다.
   4. [도메인 이름]에 가비아에서 구매한 도메인(예: my-app.com)을 입력합니다.
   5. [유형]은 [퍼블릭 호스팅 영역] (Public hosted zone)으로 선택하고 [호스팅 영역 생성] 버튼을 클릭합니다.
   6. 생성된 호스팅 영역의 상세 페이지로 들어가면, NS 타입과 SOA 타입의 레코드가 기본으로 만들어져 있습니다.
       * 중요: 타입이 `NS`인 레코드의 [값/트래픽 라우팅 대상]에 있는 4개의 네임서버 주소(예:
         ns-123.awsdns-01.org.)를 모두 복사해서 메모장에 저장해 둡니다. (가비아 설정에 필요합니다.)
   7. 이제 도메인과 EC2 IP를 연결하는 A 레코드를 생성합니다. [레코드 생성] (Create record) 버튼을 클릭합니다.
       * 레코드 이름: 비워두면 my-app.com 자체를 의미합니다. (www.my-app.com을 원하면 www를 입력)
       * 레코드 유형: `A` - IPv4 주소 및 일부 AWS 리소스로 트래픽 라우팅
       * 값: 1단계에서 할당받은 EC2의 Elastic IP 주소를 붙여넣습니다.
       * [레코드 생성] 버튼을 클릭합니다.
   8. (선택사항) www가 붙은 주소도 연결하려면, 위 7번 과정을 반복하여 [레코드 이름]에 www를 입력하고 동일한
      IP 주소로 A 레코드를 하나 더 만들어 줍니다.

  3단계: 가비아 - 네임서버 변경

  마지막으로, 가비아에 등록된 도메인이 DNS 정보를 AWS Route 53에서 찾아가도록 네임서버를 변경합니다.

   1. 가비아 홈페이지에 로그인합니다.
   2. [My가비아]로 들어갑니다.
   3. [도메인] 섹션에서 관리할 도메인 이름 옆의 [관리] 버튼을 클릭합니다.
   4. 도메인 관리 화면에서 [네임서버 설정] 또는 비슷한 이름의 메뉴를 찾습니다.
   5. 기존에 등록된 가비아 네임서버(ns.gabia.co.kr 등) 정보를 모두 삭제합니다.
   6. 2단계의 6번 항목에서 복사해 둔 4개의 AWS Route 53 네임서버 주소를 1차, 2차, 3차, 4차 네임서버 필드에 각각 붙여넣습니다. (맨 끝의 .은 빼고 입력하셔도 괜찮습니다.)
   7. [적용] 또는 [저장] 버튼을 클릭합니다.

  4단계: 전파 및 확인

  네임서버 변경 정보가 전 세계 인터넷에 전파되는 데에는 몇 분에서 최대 48시간까지 걸릴 수 있습니다.

  잠시 후 터미널에서 nslookup my-app.com 명령어를 실행했을 때, 응답으로 AWS Route 53 네임서버와 EC2의 Elastic IP 주소가 보이면 성공적으로 연결된 것입니다. 이후 웹 브라우저에서 도메인으로 접속하여 EC2에  올려둔 웹 페이지가 보이는지 최종 확인합니다.

### 3개월 무료 인증서 발급 

  Certbot의 공식 추천 설치 방법인 snap을 사용하여 진행하겠습니다.

  1단계: Certbot 설치

  터미널에 아래 명령어들을 순서대로 실행하여 Certbot을 설치합니다.

   1. snapd 코어 업데이트
```
sudo snap install core; sudo snap refresh core
````
   2. 기존 apt로 설치된 Certbot 제거 (충돌 방지)
```
sudo apt-get remove certbot
```
   3. snap을 사용하여 Certbot 설치
```
sudo snap install --classic certbot
```
   4. certbot 명령어 실행을 위한 심볼릭 링크 생성
```
sudo ln -s /snap/bin/certbot /usr/bin/certbot
```
  2단계: Certbot 실행하여 인증서 발급 및 NGINX 자동 설정

  이제 아래의 간단한 명령어 하나로 인증서 발급과 NGINX 설정을 한 번에 처리할 수 있습니다.
```
sudo certbot --nginx -d masungil.shop -d www.masungil.shop
```
  위 명령어를 실행하면, Certbot이 대화형으로 몇 가지를 물어봅니다.

   * 이메일 주소 입력: 인증서 만료가 가까워지면 알림을 받을 이메일 주소를 입력합니다. (매우 중요)
   * 서비스 약관(Terms of Service) 동의: A를 입력하여 동의합니다.
   * EFF 소식 수신 동의: 이메일로 EFF의 소식을 받을지 묻습니다. Y 또는 N으로 선택합니다.

  이 과정을 마치면, Certbot이 NGINX 설정을 분석하여 masungil.shop과 www.masungil.shop에 대한 SSL 인증서를 발급받습니다.

  그 후, HTTP 트래픽을 HTTPS로 자동 리디렉션할지 묻는 메시지가 나타납니다.
```
 Please choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 1: No redirect - Make no further changes to the webserver configuration.
 2: Redirect - Make all requests redirect to secure HTTPS access.
 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
 Select the appropriate number [1-2] then [enter] (press 'c' to cancel):
```
  보안을 위해 `2`를 선택하고 Enter를 누르는 것을 강력히 권장합니다.

  모든 과정이 성공적으로 끝나면, Certbot이 NGINX 설정 파일에 ssl_certificate, ssl_certificate_key 등의 경로를 자동으로 추가하고 NGINX를 리로드합니다.

  3단계: 자동 갱신 테스트

  Let's Encrypt 인증서는 90일 동안 유효하며, Certbot은 만료되기 전에 자동으로 갱신하도록 스케줄을
  설정합니다. 아래 명령어로 자동 갱신 프로세스가 문제없는지 테스트할 수 있습니다.
```
  sudo certbot renew --dry-run
```
  실행 결과 마지막에 에러 없이 "Congratulations, all renewals for this certificate are successful" 와 비슷한 메시지가 나타나면 자동 갱신이 정상적으로 설정된 것입니다.

  이제 웹 브라우저에서 https://masungil.shop으로 접속하여 주소창에 자물쇠 아이콘이 나타나는지 보세요.
