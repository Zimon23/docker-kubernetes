# 쿠버네티스(Kubernetes)란 무엇일까? 

## 👨‍🍳 쿠버네티스 = 레스토랑의 총괄 셰프

거대한 레스토랑을 운영한다고 상상해 보세요. 이 레스토랑에는 여러 명의 요리사(컨테이너)가 있고, 각
요리사는 특정 요리(예: 웹사이트, 데이터베이스)를 만드는 전문가입니다.

이때 쿠버네티스는 바로 '총괄 셰프'의 역할을 합니다.

총괄 셰프(쿠버네티스)가 하는 일은 다음과 같습니다.

1. 요리사 배치 (배포): "A라는 요리는 1번 주방에서 만들어!" 라고 지시합니다. 즉, 어떤 서버 컴퓨터(노드)에서 어떤 프로그램(컨테이너)을 실행할지 결정하고 배치합니다.

2. 자동 복구 (Self-Healing): 일하던 요리사 한 명이 갑자기 아파서 쓰러졌습니다! 그럼 총괄 셰프는 즉시 다른 요리사를 투입해서 요리가 멈추지 않게 합니다.

   * 마찬가지로, 프로그램에 문제가 생겨 멈추면 쿠버네티스가 자동으로 프로그램을 다시 시작시켜 서비스를 계속 유지합니다.

3. 인원 관리 (스케일링): 점심시간이 되어 손님이 몰려오면, 총괄 셰프는 "A 요리 만드는 사람 3명 더 투입해!" 라고 외칩니다. 반대로 손님이 빠지면 요리사를 줄여서 효율적으로 운영합니다.
    
    * 사용자가 몰려 웹사이트가 느려지면, 쿠버네티스는 웹사이트 프로그램(컨테이너)의 개수를 자동으로 3개, 5개, 10개로 늘려 대응합니다. 트래픽이 줄면 다시 원래대로 줄입니다.

4. 주문 분배 (로드 밸런싱): A 요리 주문이 10개 들어왔을 때, 한 명의 요리사에게 다 시키지 않고 3명의 요리사에게 3~4개씩 공평하게 나눠줍니다.
   * 웹사이트에 접속하는 많은 사람들을 여러 개의 복제된 웹사이트 프로그램으로 골고루 연결해주어, 특정 프로그램 하나만 과부하가 걸리지 않도록 합니다.

정리하면, 과거에는 서버 하나에 프로그램 하나를 설치해서 운영했습니다. 만약 그 서버가 고장 나면 서비스는 그대로 멈췄죠.

요즘은 프로그램을 컨테이너라는 표준화된 상자에 담아 관리하는데, 수십, 수백 개의 컨테이너를 사람이 일일이 관리하기는 너무 어렵습니다.

쿠버네티스는 바로 이 수많은 `컨테이너`들을 알아서 관리해주고, 문제가 생기면 자동으로 해결해주는 똑똑한 '총괄 관리 시스템(오케스트레이션 툴)'입니다.

간단한 예제: 웹사이트를 쿠버네티스로 운영하기

my-website라는 간단한 웹사이트를 만들었고, 이걸 3개의 복제본으로 항상 실행하고 싶다고 가정해 봅시다.

쿠버네티스에게는 말로 하지 않고, 설정 파일(YAML 형식)로 명령을 내립니다.

```
`my-website.yaml` (쿠버네티스에게 전달할 레시피)
vi my-website.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-website-deployment # 이 배포의 이름
spec:
  replicas: 3 # <-- "3개로 복제해서 유지해줘!" 라는 뜻
  selector:
    matchLabels:
      app: my-website
  template:
    metadata:
      labels:
        app: my-website
    spec:
      containers:
      - name: my-website-container # 컨테이너 이름
        image: nginx # <-- "nginx 라는 프로그램(웹서버)을 사용해줘!" 라는 뜻
        ports:
        - containerPort: 80
```

이제 터미널에 간단한 명령어만 입력하면 됩니다.

```
kubectl apply -f my-website.yaml
```

이 명령어를 실행하면, 총괄 셰프(쿠버네티스)가 이 레시피를 읽고 다음과 같은 일을 자동으로 처리합니다.

 1. 가장 적절한 서버 컴퓨터(노드)들을 찾습니다.
 2. 각 서버에 nginx 컨테이너를 하나씩, 총 3개를 실행합니다.
 3. 누가 이 웹사이트에 접속하면, 3개의 컨테이너 중 하나로 연결해줍니다.
 4. 만약 3개 중 1개의 컨테이너에 문제가 생기면, 즉시 다른 서버에 새로 1개를 만들어 항상 3개를 유지합니다.


이처럼 쿠버네티스를 사용하면 개발자는 복잡한 서버 관리에 신경 쓰지 않고, 오직 서비스 개발에만 집중할 수 있게 됩니다. 이것이 쿠버네티스가 현대적인 서비스 개발의 표준 기술이 된 이유입니다.

  
## 프로비저닝(Provisioning)이란?
  
IT 인프라를 생성, 설정하고 사용할 수 있도록 준비하는 모든 과정을 의미합니다.

가장 쉽게 비유하자면, 새로운 아파트에 입주하기 전에 전기, 수도, 가스, 인터넷을 신청해서 사용할 수 있는 상태로 만드는 것과 같습니다. IT 세계에서는 서버, 네트워크, 소프트웨어 등을 사용자의 요구에 맞게 할당하고 설정하는 작업을 말합니다.

 * 프로비저닝의 주요 종류

   프로비저닝은 대상에 따라 여러 종류로 나뉩니다.

 1. 서버 프로비저닝 (Server Provisioning)
  
  *  데이터 센터에 물리 서버를 설치하거나, 가상 머신(VM)을 생성하고 그 위에 운영체제(OS)를 설치, 네트워크를 설정하는 등 서버를 구동 가능한 상태로 만드는 과정입니다.

 2. 사용자 프로비저닝 (User Provisioning)
  * 사용자가 특정 시스템이나 애플리케이션에 접근할 수 있도록 계정을 생성하고, 역할(Role)에 맞는 권한(Permission)을 부여하거나 비활성화하는 작업을 말합니다. (예: 신규 입사자에게 회사 시스템 접근 계정 부여)

 3. 네트워크 프로비저닝 (Network Provisioning)
  * 라우터, 방화벽 같은 네트워크 장비를 설정하고, IP 주소, VLAN 등을 할당하여 네트워크 환경을 구성하는 과정입니다.

 4. 클라우드 프로비저닝 (Cloud Provisioning)
  * AWS, GCP, Azure와 같은 클라우드 환경에서 클릭 몇 번이나 코드 몇 줄로 가상 머신, 데이터베이스, 스토리지 등의 리소스를 할당받고 설정하는 것을 의미합니다. 오늘날 가장 흔하게 접하는 프로비저닝 형태입니다.


수동 프로비저닝 vs. 자동화된 프로비저닝

   * 수동 프로비저닝: 과거에는 관리자가 모든 과정을 직접 수동으로 처리했습니다. 이는 시간이 오래 걸리고, 사람의 실수가 발생할 가능성이 높으며, 대규모 환경에서는 비효율적입니다.

   * 자동화된 프로비저닝 (Automated Provisioning): 현재는 Terraform, Ansible, Puppet 같은 도구를 사용하여 코드로 인프라 구성을 정의하고 자동으로 프로비저닝합니다. 이를 IaC(Infrastructure as Code, 코드형 인프라)라고 부릅니다.

자동화된 프로비저닝의 장점:
 * 속도: 수 분 내에 복잡한 인프라도 구축할 수 있습니다.
 * 일관성: 코드로 정의되므로 항상 동일한 결과물이 보장되어 실수가 줄어듭니다.
 * 확장성: 필요에 따라 인프라를 쉽게 확장하거나 축소할 수 있습니다.
 * 문서화: 코드가 곧 인프라의 명세서(설계도)가 됩니다.


## 쿠버네티스 핵심 기능

쿠버네티스의 핵심 기능은 "선언적 구성(Declarative Configuration)"을 기반으로 한 "자동화된 제어 루프(Automated Control Loops)"입니다.

1. 스케줄링 (Scheduling)

  * 핵심 정의: 컨테이너(Pod)를 가장 적합한 서버(Node)에 자동으로 배치하는 기능. 쿠버네티스의 '두뇌'와 같습니다. 개발자가 "이 컨테이너를 실행해줘"라고 명령하면, 쿠버네티스의 스케줄러(Scheduler)가 다음 조건들을 종합적으로 판단하여 최적의 노드를 찾아 컨테이너를 배치합니다.

  * 리소스 요구사항: 컨테이너가 필요로 하는 CPU, 메모리 양은 얼마인가? 해당 노드에 그만큼의 여유 공간이 있는가?

  * 제약 조건 (Constraints): "이 컨테이너는 반드시 SSD가 장착된 노드에서만 실행되어야 해" 또는 "저 컨테이너와는 같은 노드에 있으면 안 돼" 와 같은 특정 규칙을 지킵니다.

  * 분산 및 안정성: 여러 개의 컨테이너를 실행할 때, 특정 노드 하나에 몰아서 배치하지 않고 여러 노드에 골고루 분산하여 하나의 노드가 고장 나도 전체 서비스에 미치는 영향을 최소화합니다.

  * 이것이 왜 중요한가? 수십, 수백 대의 서버가 있는 환경에서 개발자가 일일이 각 서버의 상태를 확인하고 어디에 프로그램을 설치할지 고민할 필요가 없습니다. 쿠버네티스가 알아서 가장 효율적이고 안정적인 위치를 찾아주기 때문입니다.

2. 자동 복구 및 고가용성 (Self-Healing & High Availability)

  * 핵심 정의: 시스템의 현재 상태를 지속적으로 감시하여, '원하는 상태(Desired State)'와 달라지면 자동으로 복구하는 기능. 쿠버네티스의 '면역 체계'입니다.

  * 사용자는 "A라는 웹서버 컨테이너가 항상 3개 실행되고 있어야 해" 라고 선언(정의)만 하면 됩니다. 그러면 쿠버네티스의 컨트롤러 매니저(Controller Manager)가 끊임없이 감시합니다.
       
  * 컨테이너 실패: 실행 중이던 컨테이너 하나가 프로그램 오류로 멈췄습니다. 컨트롤러는 즉시 "현재 상태(2개)가 원하는 상태(3개)와 다르다"고 인지하고, 새로운 컨테이너를 즉시 시작하여 3개를 맞춥니다.

  * 노드(서버) 실패: 컨테이너가 실행되던 서버 한 대가 통째로 다운되었습니다. 컨트롤러는 그 서버에서 실행되던 모든 컨테이너들을 다른 건강한(Healthy) 서버에 다시 생성하여 서비스 중단을 막습니다.

  * 이것이 왜 중요한가? 예상치 못한 장애(하드웨어 고장, 소프트웨어 버그 등)가 발생해도 사람의 개입 없이 24시간 365일 자동으로 서비스를 복구하고 유지합니다. 이를 통해 매우 높은 수준의 서비스 안정성(고가용성)을 확보할 수 있습니다.

3. 자동 확장 (Horizontal Scaling)

  * 핵심 정의: CPU 사용량과 같은 메트릭을 기반으로 컨테이너의 개수를 자동으로 늘리거나 줄이는 기능.

  * "평소에는 컨테이너 3개로 운영하되, 만약 모든 컨테이너의 평균 CPU 사용량이 70%를 넘으면 10개까지 늘려줘. 그리고 다시 70% 아래로 내려가면 3개로 줄여줘" 라는 규칙을 HPA(HorizontalPodAutoscaler) 리소스에 정의할 수 있습니다.
       
  * 스케일 아웃 (Scale-out): 트래픽이 급증하여 CPU 사용량이 설정값을 넘어서면, 쿠버네티스는 자동으로 컨테이너 복제본의 개수를 늘려 부하를 분산시킵니다.
       
  * 스케일 인 (Scale-in): 트래픽이 줄어들어 자원이 낭비되고 있으면, 컨테이너의 개수를 다시 줄여 비용을 절감합니다.

  * 이것이 왜 중요한가? 트래픽 변화를 예측하기 어려운 현대 서비스 환경에서, 사용량에 맞춰 리소스를 탄력적으로 운영할 수 있습니다. 최대 트래픽에 맞춰 과도한 서버 비용을 지불할 필요 없이, 사용한 만큼만 비용을 내는 효율적인 인프라 운영이 가능해집니다.

4. 서비스 디스커버리 및 로드 밸런싱 (Service Discovery & Load Balancing)

  * 핵심 정의: 수시로 생성되고 사라지는 컨테이너들을 자동으로 찾아 연결해주고, 그들에게 들어오는 요청(트래픽)을 분산하는 기능. 쿠버네티스의 '교통 시스템'입니다.

   * 컨테이너는 실패하면 다른 IP 주소를 가지고 다른 노드에서 다시 살아나는 등 매우 유동적입니다.
     
   * 서비스 디스커버리: 쿠버네티스는 서비스(Service) 라는 고유하고 고정된 접속 포인트를 만듭니다. 주문 컨테이너는 결제 컨테이너의 실제 IP가 무엇인지 몰라도, 그냥 '결제-서비스'라는 고정된 이름으로 요청을 보내면 쿠버네티스가 알아서 현재 실행 중인 건강한 결제 컨테이너 중 하나로 연결해줍니다.
       
   * 로드 밸런싱: '결제' 컨테이너가 여러 개(예: 3개) 실행 중이라면, 쿠버네티스 서비스는 들어오는 요청들을 이 3개의 컨테이너에 골고루 분산하여 전달합니다.

   * 이것이 왜 중요한가? 여러 개의 작은 서비스들로 구성된 마이크로서비스 아키텍처(MSA)에서 핵심적인 역할을 합니다. 개발자는 복잡한 네트워크 설정 없이도 서비스 간의 통신을 안정적으로 구현할 수 있습니다.

이 네 가지 기능은 서로 유기적으로 연결되어 있습니다. 스케줄러가 컨테이너를 배치하면, 컨트롤러가 그 상태를 감시하며 자동 복구하고, HPA가 부하에 따라 자동 확장하며, 서비스가 이 모든 유동적인 컨테이너들을 묶어 외부와 안정적으로 연결해줍니다.

결국 쿠버네티스의 가장 중요한 가치는 "복잡한 분산 시스템 운영의 완전 자동화"에 있다고 할 수 있습니다.

---

## docker swarm와 쿠버네티스의 차이점

Docker Swarm과 Kubernetes는 컨테이너 오케스트레이션이라는 동일한 목표를 가졌지만, 철학과 복잡성에서 큰 차이를 보입니다. 둘의 차이점과 장단점을 다음과 같습니다 

한눈에 보는 핵심 차이: 간단함 vs 강력함

* Docker Swarm: "간단함"과 "쉬운 사용성"에 초점을 맞춘 Docker의 네이티브(자체 내장) 오케스트레이션 도구입니다.

* Kubernetes: "강력함"과 "유연성/확장성"에 초점을 맞춘, 사실상의 업계 표준(De facto standard) 오케스트레이션 플랫폼입니다.

---

### Docker Swarm: 간단함과 신속함

✅ 장점

1. 매우 쉬운 사용법: Docker를 이미 사용하고 있다면 docker swarm init, docker service create 같은 익숙한 명령어로 모든 것을 제어할 수 있습니다. 학습 비용이 거의 없습니다.

2. 가벼움: Kubernetes에 비해 구조가 단순하여 더 적은 리소스를 필요로 합니다. 소규모 환경에 적합합니다.

3. 신속한 설정: 별도의 복잡한 설치 과정 없이 단 몇 분 만에 클러스터를 구성하고 애플리케이션을 배포할 수 있습니다.

❌ 단점

1. 제한적인 기능: Kubernetes가 제공하는 정교한 자동 확장, 자동 복구, 고급 스케줄링, 네트워킹 정책 등의 기능이 부족합니다.

2. 작은 커뮤니티와 생태계: 문제가 발생했을 때 정보를 얻거나, 연동할 수 있는 서드파티 도구를 찾기가 Kubernetes에 비해 훨씬 어렵습니다.
   
3. 확장성의 한계: 대규모의 복잡한 마이크로서비스 아키텍처를 운영하기에는 기능적으로 부족함이 있습니다.


### Kubernetes: 강력함과 확장성, 그리고 표준

✅ 장점

1. 강력하고 풍부한 기능: 자동 복구, 자동 확장, 고급 배포 전략(롤링, 카나리 등) 등 대규모 서비스를 운영하는 데 필요한 거의 모든 기능을 갖추고 있습니다.

2. 거대한 생태계와 커뮤니티: CNCF를 중심으로 한 강력한 생태계 덕분에 모니터링(Prometheus), 로깅(Fluentd), 패키지 관리(Helm) 등 필요한 거의 모든 도구가 이미 존재합니다.

3. 클라우드 지원: Google(GKE), Amazon(EKS), Microsoft(AKS) 등 모든 주요 클라우드 제공업체들이 관리형 Kubernetes 서비스를 제공하여, 복잡한 설치 과정 없이 Kubernetes의 강력한 기능을 사용할 수 있습니다.

4. 업계 표준: 컨테이너 오케스트레이션의 사실상 표준으로 자리 잡아, 관련 엔지니어를 채용하거나 기술 자료를 찾는 데 매우 유리합니다.

❌ 단점

1. 복잡성과 높은 학습 곡선: 고유한 개념과 방대한 기능 때문에 완전히 이해하고 능숙하게 사용하기까지 많은 학습 시간이 필요합니다.
   
2. 설치 및 유지보수의 어려움: (클라우드 서비스를 사용하지 않고) 직접 설치(On-premise)할 경우, 클러스터를 구축하고 유지보수하는 작업이 매우 복잡하고 어렵습니다.

3. 리소스 오버헤드: 컨트롤 플레인 자체를 실행하는 데에도 상당한 컴퓨팅 리소스가 필요하여 아주 작은 규모의 프로젝트에는 부담이 될 수 있습니다.

---

언제 무엇을 선택해야 할까?

* Docker Swarm을 선택하는 경우:
    * 팀이 소규모이고 빠르게 프로토타입을 만들거나 간단한 애플리케이션을 배포하고 싶을 때.
    * 이미 Docker에 매우 익숙하고 새로운 기술 학습에 드는 시간을 최소화하고 싶을 때.
    * 복잡한 기능 없이 단순한 컨테이너 관리만 필요할 때.

* Kubernetes를 선택하는 경우:
    * 대규모의 복잡한 마이크로서비스를 안정적으로 운영해야 할 때.
    * 높은 수준의 자동화(Auto-scaling, Self-healing)가 반드시 필요할 때.
    * 장기적인 관점에서 확장성과 유연성을 확보하고, 업계 표준 기술을 따르고 싶을 때.
    * 다양한 클라우드 네이티브 도구들과의 연동이 필요할 때.

  요약하자면, Docker Swarm은 단거리 경주에 적합한 가볍고 빠른 스쿠터이고, Kubernetes는 장거리 경주와 험지를 모두 갈 수 있는
  강력한 트럭과 같습니다. 대부분의 현대적인 상용 서비스 환경에서는 Kubernetes가 최종 선택지가 되고 있습니다.

1. "소규모 팀"의 구체적인 규모 (Docker Swarm이 적합한 경우)

  여기서의 핵심은 '인프라 전담 인력의 유무' 와 '운영 부담 최소화' 입니다.

* 팀 인원: 1명 ~ 5명 내외.

* 대부분 개발자가 서버 관리까지 함께 책임지는(DevOps 문화가 아닌, 개발자가 서버도 관리하는) 환경입니다.

* 인프라 운영을 자동화하고 관리하는 데 시간을 쏟기보다, 비즈니스 로직 개발에 집중해야 하는 스타트업 초창기나 작은 프로젝트팀이 해당됩니다.

* 프로젝트 특징:
   * 모놀리식(Monolithic) 아키텍처 또는 2~5개 내외의 소수 마이크로서비스로 구성된 애플리케이션.
   
   * 서비스 간의 상호작용이 복잡하지 않고, 전체 시스템의 구조가 한눈에 파악되는 수준입니다.
   
   * 아직 시장 검증(PMF) 단계에 있어, 빠른 프로토타이핑과 배포가 중요한 프로젝트.

   * 서버 규모: 1대 ~ 5대 내외의 서버(노드).
   
   * 클라우드에서 소규모 VM 몇 개를 사용하거나, 
   단일 물리 서버에서 운영하는 경우입니다.
   
   * 이 정도 규모에서는 Kubernetes를 도입하는 것이 오히려 '배보다 배꼽이 더 큰' 상황(관리 비용이 더 드는)이 될 수 있습니다.

2. "대규모의 복잡한 마이크로서비스"의 구체적인 사례 (Kubernetes가 필수적인 경우)

여기서의 핵심은 '서비스의 분리', '독립적인 확장과 배포', 그리고 '안정적인 운영' 입니다.

 A. 구체적인 사례: 대형 온라인 쇼핑몰 (예: 쿠팡, Amazon)

  하나의 거대한 '쇼핑몰' 프로그램을 만드는 대신, 기능별로 서비스를 전부 쪼갭니다.

   * 사용자 서비스: 회원가입, 로그인, 내 정보 관리
   * 상품 서비스: 상품 목록, 상세 정보, 재고 관리
   * 주문 서비스: 장바구니, 주문 생성, 주문 내역
   * 결제 서비스: 카드, 페이 등 외부 결제 시스템 연동
   * 배송 서비스: 배송 상태 조회, 송장 번호 관리
   * 리뷰 서비스: 상품평, 별점 관리
   * 검색/추천 엔진: 상품 검색 및 AI 기반 개인화 추천
   * ... 등 수십 개에서 수백 개의 마이크로서비스로 분리됩니다.

이 서비스들은 각각 다른 팀에서, 다른 프로그래밍 언어로 개발될 수 있으며, 서로 API를 통해 통신합니다.

B. 구체적인 규모

   * 사용자 수: 수십만 ~ 수천만 명의 가입자, 피크 타임 동시 접속자 수천 ~ 수만 명 이상.
   * 서버(노드) 대수: 수십 대에서 수백, 수천 대 이상.
   * 개발, 스테이징, 운영 환경별로 별도의 클러스터를 구성합니다.
   * 데이터 분석, AI 모델 학습 등 특수 목적을 위한 클러스터를 따로 운영하기도 합니다. 
   * CPU, 메모리, GPU 등 필요에 따라 다양한 사양의 서버들이 클러스터에 혼재합니다.
   * 운영 팀: 데브옵스(DevOps) 엔지니어, 플랫폼 엔지니어, SRE(Site Reliability Engineer) 등 인프라를 전담하는 전문 팀이 존재합니다. 이들은 개발팀이 코드를 작성하면 안정적으로 배포되고 운영될 수 있는 '플랫폼'을 만들고 관리합니다.

  C. 사용 방식 예 (Kubernetes가 어떻게 활용되는가)
    
   * 무중단 배포: 블랙프라이데이 세일을 앞두고 '주문 서비스'의 성능을 개선해야 할 때, 쇼핑몰 전체를 중단시키지 않고 오직 '주문 서비스'만 새로운 버전으로 교체합니다. (롤링 업데이트)
   
   * 자동 확장: TV 광고나 이벤트로 특정 시간에 사용자가 몰리면, '상품 서비스'와 '주문 서비스'의 컨테이너(서버)만 자동으로 50개까지 늘렸다가, 트래픽이 빠지면 다시 5개로 줄여 비용을 최적화합니다.

   * 자동 복구: '결제 서비스'의 컨테이너 중 하나가 갑자기 에러로 멈추더라도, Kubernetes가 1초 안에 감지하고 즉시 새로운 컨테이너를 띄워 결제 실패를 최소화합니다.
   
   * 리소스 관리: AI 추천 엔진처럼 GPU가 필요한 서비스는 GPU가 장착된 서버 그룹에만 배치하고, 일반 웹 서비스는 일반 서버 그룹에 배치하여 자원을 효율적으로 사용합니다.

  이처럼 수많은 서비스들이 독립적으로, 하지만 유기적으로 움직여야 하는 복잡한 환경에서는 Kubernetes의 정교한 제어와 자동화 기능이 필수적입니다.
