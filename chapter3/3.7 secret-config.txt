 1. Docker Swarm Secret (시크릿)

  1.1. Secret이란?

  Secret은 서비스에 필요한 민감한 데이터를 안전하게 저장하고 관리하기 위한 기능입니다. 예를 들어, 데이터베이스
  비밀번호, API 키, TLS 인증서, SSH 키 등 외부에 노출되어서는 안 되는 정보들이 Secret으로 관리됩니다.

  1.2. 왜 Secret을 사용해야 하는가?

   * 보안: Secret은 Swarm 클러스터 내에서 암호화되어 저장되며, 서비스 컨테이너 내부의 /run/secrets/ 디렉토리에
     읽기 전용 파일 형태로 마운트됩니다. 컨테이너 외부에서는 Secret의 내용을 직접 볼 수 없습니다.
   * 하드코딩 방지: 민감한 정보를 Docker 이미지에 직접 포함시키거나 환경 변수로 노출하는 것을 방지합니다.
     이미지에 포함되면 이미지가 유출될 경우 보안 문제가 발생하고, 환경 변수는 docker inspect 등으로 쉽게 노출될
     수 있습니다.
   * 중앙 집중식 관리: 모든 Secret은 Swarm 매니저 노드에 의해 관리되므로, 여러 서비스나 컨테이너에서 동일한
     Secret을 재사용하고 업데이트하기 용이합니다.
   * 자동 배포: 서비스가 Secret을 사용하도록 설정되면, Swarm은 해당 Secret이 필요한 노드에만 안전하게 Secret을
     전달합니다.

  1.3. Secret 작동 방식

   1. Secret 생성: docker secret create 명령어를 사용하여 파일에서 Secret을 생성합니다. 이 시점에서 Secret은
      Swarm 매니저 노드에 암호화되어 저장됩니다.
   2. 서비스에 연결: docker service create 또는 docker service update 명령어에 --secret 옵션을 사용하여
      Secret을 서비스에 연결합니다.
   3. 컨테이너에 마운트: 서비스의 태스크(컨테이너)가 실행될 때, Swarm은 해당 Secret을 컨테이너 내부의
      /run/secrets/<secret_name> 경로에 읽기 전용 파일로 마운트합니다. 컨테이너 내의 애플리케이션은 이 파일을
      읽어서 Secret 값을 사용합니다.

  1.4. Secret 예제 (데이터베이스 비밀번호)

  my-fastapi-whoami 애플리케이션을 수정하여 Secret을 사용하는 예제를 보여드리겠습니다.

  1.4.1. Secret 값 파일 생성
  데이터베이스 비밀번호를 담을 파일을 생성합니다. (실제 환경에서는 이 파일을 안전하게 관리해야 합니다.)

   echo "my_secure_db_password_123" > db_password.txt

  1.4.2. Docker Swarm Secret 생성
  db_password.txt 파일의 내용을 my_db_password라는 이름의 Secret으로 Swarm에 등록합니다.

   docker secret create my_db_password db_password.txt
  
  생성된 Secret 목록을 확인합니다:
   
   docker secret ls

  1.4.3. FastAPI 애플리케이션 수정 (`main.py`)
  컨테이너 내부에서 /run/secrets/my_db_password 파일을 읽도록 main.py를 수정합니다.

  vi main.py
# main.py
from fastapi import FastAPI, Request
import os
import socket

app = FastAPI(title="FastAPI Whoami with Secret")

# Secret 파일을 읽는 함수
def get_secret(secret_name):
    try:
        with open(f"/run/secrets/{secret_name}", "r") as secret_file:
            return secret_file.read().strip()
    except FileNotFoundError:
        return f"Secret '{secret_name}' not found or not mounted."
    except Exception as e:
        return f"Error reading secret '{secret_name}': {e}"

@app.get("/")
async def read_root(request: Request):
    hostname = socket.gethostname()
    container_id = os.getenv("HOSTNAME", hostname)

    db_password = get_secret("my_db_password") # Secret 읽기

    return {
        "hostname": container_id,
        "ip_address": request.client.host,
        "headers": dict(request.headers),
        "method": request.method,
        "path": request.url.path,
        "query_params": dict(request.query_params),
        "message": f"Hello from {container_id}!",
        "db_password_from_secret": db_password # Secret 값 포함
    }

@app.get("/health")
async def health_check():
    return {"status": "ok"}

vi requirements.txt 
#vi requirements.txt - Python 패키지 목록

fastapi
uvicorn

  1.4.4. Dockerfile (변경 없음)
  Secret을 읽는 로직은 애플리케이션 코드에 있으므로 Dockerfile은 변경할 필요가 없습니다.

  # Dockerfile (이전과 동일)
  FROM python:3.10-slim-buster
  WORKDIR /app
  COPY requirements.txt .
  RUN pip install --no-cache-dir -r requirements.txt
  COPY main.py .
  CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
  EXPOSE 8000

  1.4.5. 이미지 빌드 및 푸시
  수정된 main.py로 이미지를 다시 빌드하고 레지스트리에 푸시합니다.

   docker build -t masungil/my-fastapi-whoami-secret:latest .
   docker push masungil/my-fastapi-whoami-secret:latest

  1.4.6. Secret을 연결하여 서비스 생성
  --secret 옵션을 사용하여 my_db_password Secret을 서비스에 연결합니다.

   docker service create \
     --name my-app-with-secret \
     --publish published=8000,target=8000 \
     --replicas 1 \
     --secret my_db_password \
     masungil/my-fastapi-whoami-secret:latest

  1.4.7. 서비스 테스트
  서비스에 접속하여 응답에 db_password_from_secret 필드가 포함되어 있는지 확인합니다.

   curl 192.168.x.x:8000
  출력 예시:

   {
     "hostname": "...",
     "ip_address": "...",
     "headers": { ... },
     "method": "GET",
     "path": "/",
     "query_params": {},
     "message": "Hello from ...!",
     "db_password_from_secret": "my_secure_db_password_123"
   }
  db_password_from_secret 필드에 Secret 값이 성공적으로 표시되는 것을 확인할 수 있습니다.

  ---

  2. Docker Swarm Config (컨피그)

  2.1. Config란?

  Config는 서비스에 필요한 민감하지 않은 설정 데이터를 안전하게 저장하고 관리하기 위한 기능입니다. 예를 들어,
  웹 서버 설정 파일, 애플리케이션 설정 파일, 환경 변수 목록(민감하지 않은 경우) 등이 Config로 관리됩니다.

  2.2. 왜 Config를 사용해야 하는가?

   * 이미지 재사용성 증가: 설정 파일을 이미지에 직접 포함시키지 않고 외부에서 주입함으로써, 동일한 이미지를
     다양한 환경(개발, 테스트, 프로덕션)에서 다른 설정으로 재사용할 수 있습니다.
   * 쉬운 업데이트: 설정 변경 시 이미지를 다시 빌드하고 배포할 필요 없이, Config만 업데이트하면 서비스에
     자동으로 반영됩니다 (서비스 업데이트 필요).
   * 중앙 집중식 관리: Secret과 마찬가지로 Swarm 매니저 노드에 의해 관리되므로, 여러 서비스에서 동일한 Config를
     재사용하고 업데이트하기 용이합니다.
   * 버전 관리: Config는 Swarm 내에서 버전 관리되므로, 이전 버전으로 쉽게 롤백할 수 있습니다.

  2.3. Config 작동 방식

   1. Config 생성: docker config create 명령어를 사용하여 파일에서 Config를 생성합니다.
   2. 서비스에 연결: docker service create 또는 docker service update 명령어에 --config 옵션을 사용하여
      Config를 서비스에 연결합니다.
   3. 컨테이너에 마운트: 서비스의 태스크(컨테이너)가 실행될 때, Swarm은 해당 Config를 컨테이너 내부의 / (루트)
      디렉토리 또는 지정된 경로에 읽기 전용 파일로 마운트합니다. 기본적으로 Config 이름과 동일한 파일명으로
      마운트됩니다.

  2.4. Config 예제 (애플리케이션 설정 파일)

  my-fastapi-whoami 애플리케이션을 수정하여 Config를 사용하는 예제를 보여드리겠습니다.
  
  mkdir ~/config
  cd  ~/config

  2.4.1. Config 값 파일 생성
  애플리케이션 설정을 담을 JSON 파일을 생성합니다.
    
    vi app_config.json 
    # app_config.json
    {
      "app_name": "My Awesome Whoami App",
      "environment": "production",
      "log_level": "INFO",
      "max_connections": 100
    }

  2.4.2. Docker Swarm Config 생성
  app_config.json 파일의 내용을 my_app_config라는 이름의 Config로 Swarm에 등록합니다.

   docker config create my_app_config app_config.json
  
  생성된 Config 목록을 확인합니다:
  
  docker config ls

  2.4.3. FastAPI 애플리케이션 수정 (`main.py`)
  컨테이너 내부에서 /my_app_config (기본 마운트 경로) 또는 지정된 경로의 파일을 읽도록 main.py를 수정합니다.
  여기서는 /app/config/my_app_config.json으로 마운트하도록 지정하고 읽겠습니다.

vi main.py
# main.py
from fastapi import FastAPI, Request
import os
import socket
import json

app = FastAPI(title="FastAPI Whoami with Config")

# Config 파일을 읽는 함수
def get_config(config_path):
    try:
        with open(config_path, "r") as config_file:
            return json.load(config_file)
    except FileNotFoundError:
        return f"Config file '{config_path}' not found or not mounted."
    except json.JSONDecodeError as e:
        return f"Error decoding JSON from config '{config_path}': {e}"
    except Exception as e:
        return f"Error reading config '{config_path}': {e}"

@app.get("/")
async def read_root(request: Request):
    hostname = socket.gethostname()
    container_id = os.getenv("HOSTNAME", hostname)

    # Config 파일 읽기 (지정된 마운트 경로 사용)
    app_config = get_config("/app/config/my_app_config.json")

    return {
        "hostname": container_id,
        "ip_address": request.client.host,
        "headers": dict(request.headers),
        "method": request.method,
        "path": request.url.path,
        "query_params": dict(request.query_params),
        "message": f"Hello from {container_id}!",
        "app_configuration": app_config # Config 값 포함
    }

@app.get("/health")
async def health_check():
    return {"status": "ok"}


vi requirements.txt 
#vi requirements.txt - Python 패키지 목록

fastapi
uvicorn

  2.4.4. Dockerfile (변경 없음)
  Config를 읽는 로직은 애플리케이션 코드에 있으므로 Dockerfile은 변경할 필요가 없습니다.

vi Dockerfile
# Dockerfile (이전과 동일)
FROM python:3.10-slim-buster
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY main.py .
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
EXPOSE 8000

  2.4.5. 이미지 빌드 및 푸시
  수정된 main.py로 이미지를 다시 빌드하고 레지스트리에 푸시합니다.

   docker build -t masungil/my-fastapi-whoami-config:latest .
   docker push masungil/my-fastapi-whoami-config:latest

  2.4.6. Config를 연결하여 서비스 생성
  --config 옵션을 사용하여 my_app_config Config를 서비스에 연결합니다. target 옵션으로 컨테이너 내부의 마운트
  경로를 지정할 수 있습니다.

   docker service create \
     --name my-app-with-config \
     --publish published=8001,target=8000 \
     --replicas 1 \
     --config source=my_app_config,target=/app/config/my_app_config.json \
     masungil/my-fastapi-whoami-config:latest
   
   * source=my_app_config: Swarm에 등록된 Config의 이름입니다.
   * target=/app/config/my_app_config.json: 컨테이너 내부에서 Config가 마운트될 경로와 파일명입니다.

  2.4.7. 서비스 테스트
  서비스에 접속하여 응답에 app_configuration 필드가 포함되어 있는지 확인합니다.

   curl localhost:8001
  출력 예시:

    {
      "hostname": "...",
      "ip_address": "...",
      "headers": { ... },
      "method": "GET",
      "path": "/",
      "query_params": {},
      "message": "Hello from ...!",
      "app_configuration": {
        "app_name": "My Awesome Whoami App",
        "environment": "production",
        "log_level": "INFO",
        "max_connections": 100
      }
    }
  app_configuration 필드에 Config 값이 성공적으로 표시되는 것을 확인할 수 있습니다.

  3. 일반적인 워크플로우

   1. 파일 준비: Secret 또는 Config에 담을 내용을 파일로 준비합니다.
   2. Swarm에 생성:
       * docker secret create <secret_name> <file_path>
       * docker config create <config_name> <file_path>
   3. 서비스에 연결:
       * docker service create --secret <secret_name> ...
       * docker service create --config source=<config_name>,target=<container_path> ...
   4. 컨테이너에서 사용: 애플리케이션 코드에서 마운트된 파일을 읽어서 사용합니다.
   5. 업데이트 (필요 시):
       * docker secret update <secret_name> <new_file_path> (새로운 Secret 버전 생성)
       * docker config update <config_name> <new_file_path> (새로운 Config 버전 생성)
       * docker service update --force <service_name> (서비스를 강제로 업데이트하여 새로운 Secret/Config 버전을
         적용)

  Secret과 Config는 Docker Swarm에서 애플리케이션의 배포와 관리를 훨씬 더 안전하고 유연하게 만들어주는 강력한
  도구입니다.


