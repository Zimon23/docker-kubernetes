Mariadb - NFS 연동 방법

1단계: 사전 준비 및 계획

먼저, 3대의 리눅스 서버가 준비되어야 합니다. 이 가이드에서는 Ubuntu 24.04 LTS를 기준으로
설명합니다.

서버 역할을 다음과 같이 정하겠습니다.

┌───────────────┬────────────────────────────────────┬────────────────┐
│ 서버 호스트명 │ 역할                               │ IP 주소 (예시) │
├───────────────┼────────────────────────────────────┼────────────────┤
│ server-a      │ 마스터 + NFS 서버                  │ 192.168.0.10   │
│ server-b      │ 워커 + NFS 클라이언트              │ 192.168.0.11   │
│ server-c      │ 워커 + NFS 클라이언트              │ 192.168.0.12   │
└───────────────┴────────────────────────────────────┴────────────────┘

2단계: NFS 서버 설정 (server-a에서 실행)

Nginx의 HTML 파일들을 저장하고 모든 노드에 공유해 줄 NFS 서버를 server-a에 구성합니다.

 1. NFS 서버, vim 패키지 설치
```
sudo apt-get update
sudo apt-get install -y nfs-kernel-server
```
 2. 공유할 디렉토리 생성
    이 디렉토리가 Nginx의 웹 루트 디렉토리가 됩니다  
```   
sudo mkdir -p /mnt/nfs/db_data
```
 3. 디렉토리 권한 설정
    NFS 공유를 위해 디렉토리 소유자를 nobody:nogroup으로 변경합니다.
```
sudo chown nobody:nogroup /mnt/nfs/db_data
sudo chmod 777 /mnt/nfs/db_data
```
 4. NFS 공유 설정 파일 수정
    /etc/exports 파일에 어떤 디렉토리를 누구에게 공유할지 설정합니다.
```
sudo vi /etc/exports
```
 파일 맨 아래에 다음 내용을 추가합니다. 특정 IP 대역 192.168.0.0/24을 입력하세요.
```
/mnt/nfs/db_data *(rw,sync,no_subtree_check,no_root_squash)
```
 5. NFS 설정 적용 및 서비스 재시작
```
sudo exportfs -a
sudo systemctl restart nfs-kernel-server
```

이제 server-a는 NFS 서버로서 /mnt/nfs/db_data 디렉토리를 공유할 준비가 되었습니다.

3단계: NFS 클라이언트 설정 (server-b, server-c에서 실행)

워커 노드들이 NFS 서버의 공유 폴더를 자신의 로컬 폴더처럼 사용하기 위한 설정입니다. 
아래 과정은 `server-b`와 `server-c` 두 서버 모두에서 각각 실행해야 합니다.

 1. NFS 클라이언트, vim 패키지 설치
```
sudo apt-get update
sudo apt-get install -y nfs-common
```
 2. 마운트할 로컬 디렉토리 생성
    NFS 공유 폴더를 연결할 로컬 디렉토리를 만듭니다.
```
sudo mkdir -p /mnt/nfs/db_data
```

 3. NFS 공유 폴더 마운트 부팅 시 자동 마운트 설정
    서버가 재부팅되어도 NFS 공유 폴더가 자동으로 마운트되도록 /etc/fstab에 등록합니다.
```
sudo vi /etc/fstab

192.168.0.10:/mnt/nfs/db_data    /mnt/nfs/db_data   nfs auto,nofail,noatime,nolock,intr,tcp,actimeo=1800 0 0
```

 6. 설정 적용
    테스트 마운트를 해제하고 fstab 설정으로 다시 마운트합니다.
```
sudo mount -a
df -h
```

다시 df -h로 확인했을 때 마운트가 되어있다면 성공입니다.

4단계 : mariadb-nfs 예제    

폴더 구조 

mariadb-nfs/
├── mariadb-deployment.yaml
├── mariadb-pv.yaml
├── mariadb-pvc.yaml
├── mariadb-secret.yaml
└── mariadb-service.yaml

  이제부터는 kubectl을 사용하는 PC에서 YAML 파일을 생성하고 클러스터에 적용합니다.

  4.1. PersistentVolume (PV) 생성
  클러스터에 우리가 방금 만든 NFS 공유 디렉터리가 "사용 가능한 스토리지"임을 알려주는 PV를 생성합니다.

  중요: 아래 YAML 파일에서 <MASTER_NODE_IP> 부분을 실제 Master 노드의 IP 주소로 반드시
  변경해주세요.

  mariadb-pv.yaml 파일을 생성합니다.
```
#vi mariadb-pv.yaml

apiVersion: v1
kind: PersistentVolume
metadata:
  name: mariadb-pv
spec:
  capacity:
    storage: 5Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteMany # 여러 노드에서 읽기/쓰기 가능
  persistentVolumeReclaimPolicy: Retain
  nfs:
    # NFS 서버의 공유 디렉터리 경로
    path: /mnt/nfs/db_data
    # 중요: 이 부분을 실제 Master 노드의 IP 주소로 변경하세요!
    server: 192.168.80.159

```

4.1. PersistentVolumeClaim (PVC) 생성
mariadb  파드가 사용할 스토리지에 대한 "요청"을 나타내는 PVC를 생성합니다. 이 PVC는 위에서 정의한
 nfs-pv에 바인딩(연결)될 것입니다.

  mariadb-pvc.yaml 파일을 생성합니다.
```
#vi mariadbnfs-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mariadb-pvc
spec:
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi


```

 4.3. mariadb Deployment 생성
  이제 mariadb 파드를 배포합니다. 이 Deployment는 1개의 NGINX 파드를 생성하며, 각 파드는 위에서
  생성한 mariadb-pvc를 통해 NFS 공유 디렉터리를 /var/lib/mysql 경로에 마운트합니다. mariadb는 이
  경로에서 DB 파일을 읽고 쓰기 서비스하게 됩니다.

mariadb-deployment.yaml 파일을 생성합니다.
```
#vi mariadb-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mariadb-deployment-nfs
  labels:
    app: mariadb-nfs
spec:
  selector:
    matchLabels:
      app: mariadb-nfs
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mariadb-nfs
    spec:
      containers:
        - name: mariadb
          image: mariadb:10.5
          env:
            - name: MARIADB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mariadb-secret-nfs
                  key: MARIADB_ROOT_PASSWORD
            - name: MARIADB_DATABASE
              value: kosa_db
            - name: MARIADB_USER
              value: kosa
            - name: MARIADB_PASSWORD
              value: "1004"
          ports:
            - containerPort: 3306
          volumeMounts:
            - name: mariadb-persistent-storage
              mountPath: /var/lib/mysql
      volumes:
        - name: mariadb-persistent-storage
          persistentVolumeClaim:
            claimName: mariadb-pvc


```

4.4. Service 생성
  mariadb 파드에 접근할 수 있도록 Service를 생성합니다. 여기서는 NodePort 타입을 사용하여 클러스터 외부에서 특정 노드의 포트를 통해 mariadb에 접근할 수 있도록 합니다.

mariadb-service.yaml 파일을 생성합니다.
```
#vi mariadb-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: mariadb-service-nfs
  labels:
    app: mariadb-nfs
spec:
  selector:
    app: mariadb-nfs
  ports:
    - protocol: TCP
      port: 3306
      targetPort: 3306
  type: ClusterIP

```

5. Kubernetes 리소스 배포 및 확인

  이제 모든 YAML 파일이 준비되었습니다. 클러스터에 배포하고 정상적으로 작동하는지 확인합니다.

  5.1. PV, PVC, Deployment, Service 생성
  생성한 YAML 파일들을 순서대로 클러스터에 적용합니다.
```
kubectl apply -f .
```

  7.2. 배포 상태 확인
```
kubectl get pv,pvc,deployment,svc,pods -l app=mariadb-nfs
```
   * mariadb-pv와 mariadb-pvc의 STATUS가 모두 Bound여야 합니다.
   * mariadb-deployment-nfs READY가 1/1여야 합니다.
   * mariadb-nfs 파드가 Running 상태여야 합니다.
   * 중요: mariadb-nfs 파드가 임의의 node에 스케줄링되었는지 확인하세요.

  5.3. MariaDB 접속 및 데이터 영속성 테스트

   1. MariaDB 접속 테스트:
      MariaDB 파드에 접속하여 데이터베이스에 로그인하고 데이터를 생성해봅니다.

#### MariaDB 파드 이름 확인
```
kubectl get pod 
```

#### 파드에 접속 (예: mariadb-deployment-nfs-xxxx-yyyy)
```
kubectl exec -it mariadb-deployment-nfs-d77585f54-b8vqn -- mariadb -u root -p
```
#### 비밀번호는 mariadb-secret-nfs에 설정한 '1004' 입니다.

#### 데이터베이스 생성 및 사용
```
USE kosa_db;
CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255));
INSERT INTO users (name) VALUES ('Charlie'), ('David');
SELECT * FROM users;
# exit;
```
   2. 파드 삭제 후 영속성 확인:
      MariaDB 파드를 강제로 삭제하여 파드가 재스케줄링되도록 합니다.
```
# MariaDB 파드 이름 확인
kubectl get pods -l app=mariadb-nfs

# 파드 삭제
kubectl delete pod <YOUR_MARIADB_POD_NAME>
```
      잠시 후, 새로운 MariaDB 파드가 다시 Running 상태가 될 것입니다.
```
kubectl get pods -l app=mariadb-nfs
```
      새로 생성된 MariaDB 파드에 다시 접속하여 이전에 생성했던 데이터가 그대로 남아있는지 확인합니다.
```
# 새로운 MariaDB 파드 이름 확인
kubectl get pods 

# 새로운 파드에 접속
kubectl exec -it <NEW_MARIADB_POD_NAME> -- mariadb -u root -p
# 비밀번호 입력

# 데이터 확인
USE kosa_db;
SELECT * FROM users;
# exit;
```

이전에 입력했던 'Charlie'와 'David' 데이터가 그대로 출력된다면, nfs PV/PVC를 통한 MariaDB 데이터의 영속성이 성공적으로 작동하는 것입니다.