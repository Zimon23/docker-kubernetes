### hostPath와 emptyDir

 중요한 볼륨 유형인 hostPath와 emptyDir은 컨테이너의 일시적인 파일 시스템을 넘어 데이터를 관리하기 위한 첫걸음입니다.

  근본적인 필요성: 왜 볼륨(Volume)이 필요한가?

  컨테이너의 파일 시스템은 기본적으로 일시적(Ephemeral)입니다. 컨테이너가 비정상적으로 종료되거나 재시작되면 컨테이너 내부에 저장했던 모든 데이터가 사라집니다. 또한, 하나의 파드(Pod) 내에서 여러  컨테이너가 실행될 때, 이 컨테이너들끼리 파일을 직접 공유할 방법이 필요합니다.

  Kubernetes의 볼륨(Volume)은 이러한 문제를 해결하기 위해 등장했습니다. 볼륨은 파드의 생명주기에 맞춰 존재하며, 컨테이너가 재시작되어도 데이터는 보존됩니다. emptyDir와 hostPath는 이 볼륨의 가장 기본적인 가지 유형입니다.

  ---

  1. emptyDir 볼륨

  emptyDir는 이름 그대로 "빈 디렉터리"를 의미합니다.

  (1) emptyDir란 무엇이고 왜 필요한가?

   * 생성 시점: 파드가 노드(Node)에 할당될 때 생성됩니다.
   * 생명 주기: 파드가 존재하는 동안에만 유지됩니다. 파드가 삭제되면 emptyDir의 데이터도 함께 영구히 삭제됩니다. 컨테이너가 충돌 등으로 재시작되어도 데이터는 보존됩니다.
   * 주요 목적:
       1. 임시 데이터 저장 공간 (Scratch Space): 애플리케이션이 실행 중에만 필요한 임시 파일을 저장하는 용도 (예: 정렬, 계산 중 중간 결과물).
       2. 파드 내 컨테이너 간 파일 공유: 하나의 파드 안에서 실행되는 여러 컨테이너가 파일을 주고받는 가장 확실하고 효율적인 방법입니다. (예: 사이드카 패턴)

  (2) emptyDir 실무 예제: 웹서버와 로그 수집 사이드카

  가장 흔한 emptyDir 사용 예는 메인 애플리케이션 컨테이너가 생성하는 데이터를 사이드카(Sidecar) 컨테이너가 읽어서 처리하는 구조입니다.

   * 시나리오:
       1. main-app 컨테이너는 5초마다 현재 시간을 파일에 쓴다.
       2. sidecar 컨테이너는 5초마다 이 파일을 읽어 자신의 로그(stdout)로 출력한다.

```
# vi emptydir-pod.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: emptydir-example
spec:
  # 1. `emptyDir` 볼륨을 "shared-data" 라는 이름으로 정의합니다.
  volumes:
  - name: shared-data
    emptyDir: {}

  containers:
  # 메인 앱 컨테이너: 5초마다 /data/time.log 파일에 현재 시간을 기록합니다.
  - name: main-app
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
    - |
      while true; do
        echo "$(date)" > /data/time.log;
        echo "Wrote time to /data/time.log";
        sleep 5;
      done
    # 2. 위에서 정의한 "shared-data" 볼륨을 컨테이너의 /data 경로에 마운트합니다.
    volumeMounts:
    - name: shared-data
      mountPath: /data

  # 사이드카 컨테이너: 5초마다 /shared/time.log 파일을 읽어 로그로 출력합니다.
  - name: sidecar
    image: busybox
    command: ["/bin/sh", "-c"]
    args:
    - |
      while true; do
        if [ -f /shared/time.log ]; then
          echo "Sidecar reading: $(cat /shared/time.log)";
        fi;
        sleep 5;
      done
    # 3. 동일한 "shared-data" 볼륨을 컨테이너의 /shared 경로에 마운트합니다.
    volumeMounts:
    - name: shared-data
      mountPath: /shared


```

실행 방법 
```
kubectl apply -f emptydir-pod.yaml
```

파드 목록 확인  
```
kubectl get pod 
```


 (3) emptydir-pod.yaml 설명 및 실행

   * YAML 설명:
       * spec.volumes: emptyDir 타입의 shared-data라는 볼륨을 정의했습니다.
       * main-app 컨테이너: shared-data 볼륨을 /data 경로에 마운트하고, 이 경로에 time.log 파일을 생성합니다.
       * sidecar 컨테이너: 동일한 shared-data 볼륨을 /shared 경로에 마운트하고, 이 경로에서 time.log 파일을 읽습니다.
       * 두 컨테이너는 emptyDir를 통해 **같은 디렉터리를 공유**하게 되므로 **파일 공유**가 가능해집니다.

   * 실행 및 확인(두개의 터미널 사용하여 확인한다)

파드 main-app 컨테이너 로그 확인   
```
kubectl logs -f emptydir-example main-app 
```

파드 sidecar 컨테이너 로그 확인  
```
kubectl logs -f emptydir-example sidecar
```

* 이 명령어를 실행하면, sidecar 컨테이너가 main-app이 기록한 시간 값을 성공적으로 읽어 출력하는 것을 볼 수 있습니다.

  ---

  2. hostPath 볼륨

  hostPath는 파드가 실행 중인 호스트 노드(Host Node)의 파일 시스템에 있는 파일이나 디렉터리를 파드에 직접 마운트합니다.

  (1) hostPath란 무엇이고 왜 필요한가?

   * 개념: 컨테이너가 노드의 파일 시스템에 직접 접근할 수 있게 해주는 강력한 기능입니다.
   * 필요성: 일반적으로 애플리케이션은 노드에 대해 알 필요가 없지만, 특정 시스템 레벨의 작업을 수행하는 파드는 노드의 파일에 접근해야 합니다.
       * 노드 모니터링: 노드의 로그 파일(/var/log)이나 시스템 정보(/proc, /sys)를 읽는 에이전트 (예: Fluentd, Prometheus Node Exporter).
       * 노드 관리: 노드의 Docker 소켓(/var/run/docker.sock)에 접근하여 다른 컨테이너를 관리하는 에이전트.
   * ⚠️ 매우 중요한 주의사항:
       * 보안 위험: hostPath는 매우 위험할 수 있습니다. 만약 컨테이너가 해킹당하면, 공격자는 노드의 파일 시스템에 접근하여 노드 전체를 장악할 수 있습니다. 따라서 꼭 필요한 경우에만 최소한의 권한으로 사용해야 합니다.
       * 이식성 저하: 파드는 이제 특정 파일 구조를 가진 노드에서만 정상 동작하게 됩니다. 만약 파드가 다른 노드로 스케줄링되면, 해당 경로에 파일이 없어 오류가 발생할 수 있습니다. 일반적인 애플리케이션의 데이터 저장 용도로는 절대 사용하면 안 됩니다.

  (2) hostPath 실무 예제: 노드의 로그 디렉터리 접근

   * 시나리오: 파드를 배포하여, 파드가 실행되고 있는 노드의 /var/log 디렉터리 내용을 컨테이너 안에서 확인합니다.

```
#vi hostpath-pod.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: hostpath-example
spec:
  # 1. `hostPath` 볼륨을 "host-logs" 라는 이름으로 정의합니다.
  volumes:
  - name: host-logs
    hostPath:
      # 노드의 /var/log 경로를 사용합니다.
      path: /var/log
      # 이 경로의 타입이 디렉터리여야 함을 명시합니다. (권장)
      type: Directory

  containers:
  - name: log-reader-container
    image: busybox
    # 컨테이너가 계속 실행되도록 유지합니다.
    command: ["/bin/sh", "-c"]
    args:
    - |
      while true; do
        ls -la /mnt/host-logs
        sleep 5;
      done
    # 2. 위에서 정의한 "host-logs" 볼륨을 컨테이너의 /mnt/host-logs 경로에 마운트합니다.
    volumeMounts:
    - name: host-logs
      mountPath: /mnt/host-logs
      # 읽기 전용으로 마운트하여 보안을 강화합니다.
      readOnly: true

```

✦ (3) hostpath-pod.yaml 설명 및 실행

   * YAML 설명:
       * spec.volumes: hostPath 타입의 host-logs 볼륨을 정의하고, 노드의 /var/log 경로를 지정했습니다. type: Directory는 해당 경로가 존재하고 디렉터리 타입일 때만 마운트되도록 하여 안정성을 높입니다.
       * log-reader-container: host-logs 볼륨을 컨테이너 내부의 /mnt/host-logs 경로에 마운트했습니다. readOnly: true 옵션으로 컨테이너가 노드의 파일을 수정하지 못하게 막는 것이 보안상 좋은 습관입니다.

   * 실행 및 확인:
       1. 파드 생성: kubectl apply -f hostpath-pod.yaml
       2. 새로운 터미널에서 파드 로그 출력: kubectl logs -f hostpath-example
       3. 새로운 터미널에서 컨테이너 접속: kubectl exec -it hostpath-example -- /bin/sh
       4. 마운트된 경로 확인: 컨테이너 셸에서 ls -l /mnt/host-logs 명령어를 실행합니다.
           * 파드가 실행 중인 쿠버네티스 노드의 /var/log 디렉터리에 있는 파일 목록이 그대로 출력되는 것을 확인할 수 있습니다.
       5. 새로운 터미널을 열어 실행되는 노드에서 /var/log 폴더에 파일을 추가해보고 로그 출력에 새로운 파일 정보가  나오는지 확인한다

  ---

