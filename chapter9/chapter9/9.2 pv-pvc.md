### PersistentVolume (PV)과 PersistentVolumeClaim (PVC)

PersistentVolume (PV)과 PersistentVolumeClaim (PVC)은 컨테이너화된 애플리케이션의 데이터 영속성(Persistence)을 다루는 핵심 개념입니다. 컨테이너는 기본적으로 상태가 없으며(stateless) 임시적(ephemeral)입니다. 즉, 컨테이너가 재시작되거나 삭제되면 그 안에 저장된 모든 데이터는 사라집니다. 데이터베이스, 메시지 큐, 파일 서버 등 상태를 유지해야 하는 애플리케이션에는 이러한 임시성이 큰 문제가 됩니다.

PV와 PVC는 이러한 문제를 해결하여, 파드(Pod)의 생명주기와 독립적으로 데이터를 저장하고 관리할 수 있도록 해줍니다.

  ---

1. PersistentVolume (PV) 이란 무엇인가?

   * 정의: PersistentVolume은 클러스터 내에서 프로비저닝(provisioning)된 스토리지의 한 조각을
     나타냅니다. 이는 클러스터 관리자가 설정하거나, StorageClass를 통해 동적으로 프로비저닝될 수
     있습니다. PV는 네트워크 파일 시스템(NFS), 클라우드 제공업체의 스토리지(AWS EBS, Google
     Persistent Disk, Azure Disk 등), iSCSI 등 다양한 유형의 실제 물리적 또는 네트워크 스토리지를
     추상화합니다.
   * 비유: 데이터센터의 서버 랙에 꽂혀 있는 실제 하드 드라이브나 네트워크 스토리지 장치와 같습니다.
     클러스터 관리자가 "이만큼의 스토리지가 사용 가능합니다"라고 선언하는 것입니다.
   * 주요 속성:
       * capacity: 스토리지의 크기 (예: 10Gi).
       * accessModes: 스토리지가 어떻게 접근될 수 있는지 정의합니다.
           * ReadWriteOnce (RWO): 단일 노드에서만 읽기/쓰기 가능 (대부분의 블록 스토리지).
           * ReadOnlyMany (ROX): 여러 노드에서 읽기만 가능.
           * ReadWriteMany (RWX): 여러 노드에서 읽기/쓰기 가능 (NFS와 같은 공유 파일 시스템).
       * volumeMode: Filesystem (기본값) 또는 Block (로우 블록 장치).
       * persistentVolumeReclaimPolicy: PV가 PVC에서 해제될 때 어떻게 처리될지 정의합니다.
           * Retain: 수동으로 회수해야 합니다. 데이터는 보존됩니다.
           * Delete: PV와 함께 기본 스토리지도 삭제됩니다.
           * Recycle (더 이상 사용되지 않음): 데이터를 삭제하고 볼륨을 재사용 가능하게 만듭니다.
       * storageClassName: 특정 StorageClass와 연결하여 동적 프로비저닝에 사용됩니다.
       * nfs, awsElasticBlockStore, gcePersistentDisk 등: 실제 스토리지의 유형과 연결 정보를
         정의합니다.

  ---

  2. PersistentVolumeClaim (PVC) 이란 무엇인가?

   * 정의: PersistentVolumeClaim은 사용자가 PersistentVolume에 대해 요청하는 것입니다. 개발자나
     애플리케이션은 특정 크기, 접근 모드, 스토리지 클래스를 가진 스토리지를 요청합니다.
   * 비유: 데이터센터 사용자(개발자)가 IT 부서(클러스터)에 "저는 10GB짜리 읽기/쓰기 가능한
     스토리지가 필요합니다"라고 요청하는 양식과 같습니다.
   * 주요 속성:
       * accessModes: PV와 동일하게 접근 모드를 요청합니다. PV의 accessModes와 호환되어야 합니다.
       * resources.requests.storage: 필요한 스토리지의 크기를 요청합니다.
       * storageClassName: 특정 StorageClass를 지정하여 해당 클래스에 맞는 PV를 요청합니다.

  ---

  3. PV/PVC를 왜 사용해야 하는가?

  PV와 PVC는 다음과 같은 중요한 문제를 해결합니다.

   1. 스토리지와 파드의 분리 (Decoupling):
       * 개발자는 파드를 배포할 때 스토리지의 세부 구현(NFS 서버 IP, 클라우드 볼륨 ID 등)을 알
         필요가 없습니다. 그저 필요한 스토리지의 "특성"만 요청하면 됩니다.
       * 클러스터 관리자는 스토리지 인프라를 독립적으로 관리하고, 다양한 스토리지 옵션을 제공할 수
         있습니다.

   2. 데이터 영속성 (Data Persistence):
       * 파드가 삭제되거나 재스케줄링되어도 PV에 저장된 데이터는 그대로 유지됩니다. 이는
         데이터베이스, 로그 서버 등 상태를 유지해야 하는 애플리케이션에 필수적입니다.

   3. 이식성 (Portability):
       * 파드는 어떤 노드에 스케줄링되더라도 동일한 PVC를 통해 동일한 PV에 접근할 수 있습니다 (물론
         PV의 accessModes와 스토리지 유형에 따라 다름). 이는 hostPath와 같은 노드 종속적인 볼륨의
         한계를 극복합니다.

   4. 추상화 (Abstraction):
       * PV는 실제 스토리지를 추상화하고, PVC는 스토리지 요청을 추상화합니다. 이 계층 덕분에
         개발자와 관리자 모두 자신의 역할에 집중할 수 있습니다.

   5. 동적 프로비저닝 (Dynamic Provisioning):
       * StorageClass와 함께 사용하면, PVC 요청 시 클러스터가 자동으로 PV를 생성하고 바인딩할 수
         있습니다. 이는 수동으로 PV를 생성할 필요 없이 스토리지 관리를 자동화하여 운영 효율성을
         크게 높입니다.

  ---

  4. 실무에서 PV/PVC는 어떻게 사용되는가?

  PV/PVC는 Kubernetes에서 상태 저장(Stateful) 애플리케이션을 배포할 때 거의 항상 사용됩니다.

   * 데이터베이스: MySQL, PostgreSQL, MongoDB, Cassandra 등 모든 종류의 데이터베이스는 데이터를
     영구적으로 저장해야 하므로 PV/PVC를 사용합니다.
   * 메시지 큐: Kafka, RabbitMQ 등 메시지 브로커는 메시지를 디스크에 저장해야 하므로 PV/PVC가
     필요합니다.
   * 파일 서버/CMS: WordPress, Nextcloud와 같은 콘텐츠 관리 시스템은 사용자 업로드 파일, 이미지 등을
     저장하기 위해 PV/PVC를 사용합니다.
   * 로깅/모니터링 스택: Elasticsearch, Prometheus 등은 수집된 로그나 메트릭 데이터를 저장하기 위해
     PV/PVC를 사용합니다.
   * CI/CD 파이프라인: 빌드 아티팩트, 캐시 등을 저장하는 데 사용될 수 있습니다.

 
  MariaDB와 같은 관계형 데이터베이스는 모든 데이터를 파일 시스템에 저장합니다. 이 데이터는
  애플리케이션의 핵심이며, 절대 손실되어서는 안 됩니다.

   * 데이터 영속성: 파드가 재시작되거나 다른 노드로 이동하더라도 데이터베이스의 데이터는 그대로
     유지되어야 합니다. PV/PVC는 이를 보장합니다.
   * 단일 쓰기 접근 (ReadWriteOnce): 대부분의 관계형 데이터베이스는 데이터 손상을 방지하기 위해 한
     번에 하나의 인스턴스만 데이터 디렉터리에 쓰기 접근을 해야 합니다. 따라서 MariaDB 파드는
     일반적으로 ReadWriteOnce (RWO) 접근 모드를 가진 PV/PVC를 사용합니다. (NFS는 ReadWriteMany를
     지원하지만, 데이터베이스의 경우 단일 파드만 쓰기 접근하도록 구성해야 합니다.)
   * 파드 독립성: 데이터베이스 파드가 어떤 이유로든 종료되거나 재스케줄링될 때, 새로운 파드는
     기존의 영속적인 데이터에 다시 연결하여 중단 없이 서비스를 재개할 수 있습니다.

5. PV와 PVC가 연결(바인딩)되는 기준  
  
PersistentVolume (PV)와 PersistentVolumeClaim (PVC)은 Kubernetes에서 스토리지 리소스를 추상화하고
 관리하는 핵심 메커니즘입니다. 이 둘은 마치 공급자(PV)와 소비자(PVC)의 계약처럼 연결되어 동작합니다.

  PV와 PVC가 연결(바인딩)되는 과정과 기준은 다음과 같습니다.

  1. PV/PVC 바인딩의 목표

  PV와 PVC의 바인딩 목표는 사용자가 요청한 스토리지의 특성(PVC)에 가장 적합한 사용 가능한 스토리지
  리소스(PV)를 찾아 연결하는 것입니다.

  ---

  2. 바인딩 과정

  Kubernetes 컨트롤 플레인(특히 kube-controller-manager 내의 볼륨 컨트롤러)은 지속적으로 다음을 감시합니다:

   1. `Pending` 상태의 PVC: 아직 어떤 PV에도 바인딩되지 않은 PVC가 있는지 확인합니다.
   2. `Available` 상태의 PV: 아직 어떤 PVC에도 바인딩되지 않은 PV가 있는지 확인합니다.

  새로운 PVC가 생성되거나 새로운 PV가 생성되어 Available 상태가 되면, 컨트롤러는 이 둘을 서로
  매칭시키려고 시도합니다.

  ---

  3. PV와 PVC가 연결되는 기준 (바인딩 규칙)

  PV와 PVC가 성공적으로 바인딩되기 위해서는 다음의 모든 조건이 충족되어야 합니다.

  3.1. 용량 (Capacity)

   * 기준: PV가 제공하는 capacity.storage는 PVC가 resources.requests.storage로 요청하는 용량보다
     크거나 같아야 합니다.
   * 예시: PVC가 5Gi를 요청하면, PV는 5Gi 이상을 제공해야 합니다.

  3.2. 접근 모드 (Access Modes)

   * 기준: PV가 제공하는 accessModes는 PVC가 요청하는 accessModes를 모두 만족해야 합니다. 즉, PVC가
     요청하는 모든 접근 모드를 PV가 지원해야 합니다.
   * 예시:
       * PVC가 ReadWriteOnce를 요청하면, PV는 최소한 ReadWriteOnce를 제공해야 합니다.
       * PVC가 ReadWriteMany를 요청하면, PV는 반드시 ReadWriteMany를 제공해야 합니다. (PV가
         ReadWriteOnce만 제공한다면 바인딩되지 않습니다.)
       * PV가 ReadWriteMany를 제공한다면, 이 PV는 ReadWriteOnce, ReadOnlyMany, ReadWriteMany 중 어떤
         것을 요청하는 PVC와도 바인딩될 수 있습니다.

  3.3. 볼륨 모드 (Volume Mode)

   * 기준: PV의 volumeMode (Filesystem 또는 Block)는 PVC가 요청하는 volumeMode와 정확히 일치해야
     합니다.
   * 예시: PVC가 volumeMode: Block을 요청하면, PV도 volumeMode: Block이어야 합니다.

  3.4. 스토리지 클래스 (StorageClass) - 가장 중요한 기준

  StorageClass는 PV와 PVC를 연결하는 가장 현대적이고 유연한 방법입니다.

   * PVC가 `storageClassName`을 지정한 경우:
       * PVC는 해당 storageClassName과 정확히 일치하는 storageClassName을 가진 PV에만 바인딩될 수
         있습니다.
       * 동적 프로비저닝: 만약 적합한 PV가 없다면, Kubernetes는 해당 StorageClass에 정의된
         프로비저너를 사용하여 요청에 맞는 새로운 PV를 자동으로 생성하고 PVC에 바인딩합니다. 이것이
         현대 Kubernetes에서 가장 흔하게 사용되는 방식입니다.
   * PVC가 `storageClassName: ""` (빈 문자열)을 지정한 경우:
       * PVC는 storageClassName이 정의되지 않은 (즉, storageClassName 필드가 없는) PV에만 바인딩될
         수 있습니다.
       * 이는 주로 수동으로 생성된 PV(정적 프로비저닝)에 바인딩할 때 사용됩니다.
   * PVC가 `storageClassName`을 아예 지정하지 않은 경우:
       * 클러스터에 default로 지정된 StorageClass가 있다면, 해당 StorageClass를 사용하여 PV를
         동적으로 프로비저닝하거나, 해당 StorageClass를 가진 PV에 바인딩됩니다.
       * default StorageClass가 없다면, storageClassName이 없는 PV 중에서 바인딩을 시도합니다.

  3.5. 선택자 (Selector) - 정적 프로비저닝 시

   * 기준: PVC가 selector 필드를 사용하여 특정 레이블을 가진 PV를 요청할 수 있습니다. 이 경우, PV는
     PVC의 selector에 정의된 레이블과 일치하는 레이블을 가지고 있어야 바인딩될 수 있습니다.
   * 주요 사용처: 클러스터 관리자가 특정 목적을 위해 수동으로 PV를 생성하고, 개발자가 그 PV를
     명시적으로 선택하여 사용하고 싶을 때 사용됩니다.

  3.6. 볼륨 이름 (VolumeName) - 정적 프로비저닝 시

   * 기준: PVC가 volumeName 필드를 사용하여 특정 PV의 이름을 직접 지정할 수 있습니다. 이 경우,
     PVC는 해당 이름의 PV에 명시적으로 바인딩됩니다.
   * 주요 사용처: 가장 직접적인 바인딩 방법으로, 특정 PV에 PVC를 정확히 연결해야 할 때 사용됩니다.



6. hostPath PV/PVC와 MariaDB 예제 (간단한 테스트)

  hostPath는 파드가 실행되는 특정 노드의 파일 시스템에 직접 데이터를 저장합니다.

   * 장점: 별도의 네트워크 스토리지(NFS 서버 등) 설정 없이 로컬 파일 시스템을 PV로 사용할 수 있어
     간단한 테스트나 단일 노드 환경에서 유용합니다.
   * 단점 (매우 중요):
       * 데이터의 노드 종속성: 데이터가 특정 노드에 묶입니다. 만약 해당 노드가 다운되거나 파드가
         다른 노드로 재스케줄링되면, 데이터에 접근할 수 없게 됩니다. 이는 프로덕션 환경의
         데이터베이스에는 치명적입니다.
       * 확장성 및 고가용성 부족: 여러 파드가 동일한 hostPath PV를 공유하기 어렵고, 노드 장애 시
         데이터 유실 위험이 큽니다.
       * 보안 위험: 컨테이너가 노드의 파일 시스템에 직접 접근하므로, 보안 취약점이 발생할 수
         있습니다.

  따라서 hostPath PV는 학습, 개발, 테스트 목적으로만 사용해야 하며, 프로덕션 환경의
  데이터베이스에는 절대 권장되지 않습니다. 프로덕션에서는 클라우드 제공업체의 블록 스토리지(AWS
  EBS, GCE PD 등)나 분산 파일 시스템(Ceph, GlusterFS 등)을 사용하는 StorageClass 기반의 동적
  프로비저닝을 활용해야 합니다.

  이 예제에서는 MariaDB 파드가 특정 Worker 노드(k8s-node1을 가정)에 스케줄링되도록 nodeName을 지정할
  것입니다.

  ---

  단계별 MariaDB (hostPath) 예제

폴더 구조

mariadb-exam/
├── mariadb-deployment.yaml
├── mariadb-pv.yaml
├── mariadb-pvc.yaml
├── mariadb-secret.yaml
└── mariadb-service.yaml

 사전 준비 (매우 중요)

  6.1. MariaDB 루트 비밀번호 Secret 생성 (mariadb-secret.yaml)

```
#vi mariadb-secret.yaml
apiVersion: v1                                                      
kind: Secret                                                        
metadata:                                                           
  name: mariadb-secret-hostpath                                     
type: Opaque                                                        
data:                                                               
  # 'your_root_password'를 base64 인코딩한 값입니다.                
  # 예: echo -n '1004' | base64                         
  # 실제 사용 시에는 안전한 비밀번호로 변경하고 직접 인코딩하세요.  
  MARIADB_ROOT_PASSWORD: MTAwNA==              

```

  6.2. PersistentVolume (PV) 생성 (mariadb-pv.yaml)

  hostPath 타입의 PV를 정의합니다.

  mariadb-pv.yaml 파일을 생성합니다.
```
#vi mariadb-pv.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mariadb-pv
spec:
  capacity:
    storage: 5Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce # MariaDB는 단일 파드만 쓰기 접근
  persistentVolumeReclaimPolicy: Retain
  hostPath:
    path: /mnt/data/mariadb # 파드가 스케줄링될 노드에 이 경로가 존재해야 합니다.
    type: DirectoryOrCreate # 디렉터리가 없으면 생성합니다.
```
* 설명: mariadb-pv라는 PV를 정의합니다. hostPath 타입이며, 노드의 /mnt/data/mariadb 경로를 사용합니다. type: DirectoryOrCreate는 해당 경로가 없으면 생성하도록 합니다.

  6.3. PersistentVolumeClaim (PVC) 생성 (mariadb-pvc.yaml)

  MariaDB 파드가 사용할 스토리지에 대한 요청을 나타내는 PVC를 생성합니다.

  mariadb-pvc.yaml 파일을 생성합니다.
```
#vi mariadb-pvc.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mariadb-pvc
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi

```
* 설명: mariadb-pvc라는 PVC를 정의합니다. mariadb-pv-hostpath와 동일한 accessModes와 충분한 storage를 요청합니다.

  6.4. MariaDB Deployment 생성 (mariadb-deployment.yaml)

  MariaDB 파드를 배포합니다. 이 Deployment는 단일 MariaDB 파드를 생성하며, mariadb-pvc를
  /var/lib/mysql 경로에 마운트합니다.

  중요: nodeName: k8s-node1 부분을 MariaDB 파드를 스케줄링할 실제 Worker 노드의 이름으로 변경하세요.

  mariadb-deployment.yaml 파일을 생성합니다.
```
#vi mariadb-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mariadb-deployment-hostpath
  labels:
    app: mariadb-hostpath
spec:
  selector:
    matchLabels:
      app: mariadb-hostpath
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: mariadb-hostpath
    spec:
      # 중요: 이 부분을 MariaDB 파드를 스케줄링할 실제 Worker 노드의 이름으로 변경하세요.
      nodeName: k8s-node1 
      containers:
        - name: mariadb
          image: mariadb:10.5
          env:
            - name: MARIADB_ROOT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mariadb-secret-hostpath
                  key: MARIADB_ROOT_PASSWORD
            - name: MARIADB_DATABASE
              value: kosa_db
            - name: MARIADB_USER
              value: kosa
            - name: MARIADB_PASSWORD
              value: "1004"
          ports:
            - containerPort: 3306
          volumeMounts:
            - name: mariadb-persistent-storage
              mountPath: /var/lib/mysql
      volumes:
        - name: mariadb-persistent-storage
          persistentVolumeClaim:
            claimName: mariadb-pvc

```
* 설명: mariadb-deployment-hostpath는 단일 MariaDB 파드를 생성합니다. nodeName: k8s-node1은 이 파드가 k8s-node1에만 스케줄링되도록 강제합니다. 이는 hostPath PV가 특정 노드에만 존재하기 때문에 필수적입니다.

  6.5. MariaDB Service 생성 (mariadb-service.yaml)

  클러스터 내부의 다른 파드들이 MariaDB에 접근할 수 있도록 ClusterIP 타입의 Service를 생성합니다.

  mariadb-exam/mariadb-service.yaml 파일을 생성합니다.
```
#vi mariadb-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: mariadb-service-hostpath
  labels:
    app: mariadb-hostpath
spec:
  selector:
    app: mariadb-hostpath
  ports:
    - protocol: TCP
      port: 3306
      targetPort: 3306
  type: ClusterIP

```
* 설명: mariadb-service-hostpath는 mariadb-hostpath 레이블을 가진 파드들을 대상으로 트래픽을 라우팅합니다.

  ---

7. Kubernetes 리소스 배포 및 영속성 확인

  이제 모든 YAML 파일이 준비되었습니다. 클러스터에 배포하고 정상적으로 작동하는지 확인합니다.

  7.1. 리소스 배포
```
# Secret 생성
kubectl apply -f mariadb-exam/mariadb-secret.yaml

# PV 생성
kubectl apply -f mariadb-exam/mariadb-pv.yaml

# PVC 생성
kubectl apply -f mariadb-exam/mariadb-pvc.yaml

# PV와 PVC가 바인딩될 때까지 잠시 기다립니다.
kubectl get pv mariadb-pv-hostpath
kubectl get pvc mariadb-pvc-hostpath

# MariaDB Deployment 생성
kubectl apply -f mariadb-exam/mariadb-deployment.yaml

# MariaDB Service 생성
kubectl apply -f mariadb-exam/mariadb-service.yaml
```

  7.2. 배포 상태 확인
```
kubectl get pv,pvc,deployment,svc,pods -l app=mariadb-hostpath
```
   * mariadb-pv와 mariadb-pvc의 STATUS가 모두 Bound여야 합니다.
   * mariadb-deployment-hostpath의 READY가 1/1여야 합니다.
   * mariadb-hostpath 파드가 Running 상태여야 합니다.
   * 중요: mariadb-hostpath 파드가 node1 (또는 지정한 노드)에 스케줄링되었는지 확인하세요.

  7.3. MariaDB 접속 및 데이터 영속성 테스트

   1. MariaDB 접속 테스트:
      MariaDB 파드에 접속하여 데이터베이스에 로그인하고 데이터를 생성해봅니다.

#### MariaDB 파드 이름 확인
```
kubectl get pod 
```

#### 파드에 접속 (예: mariadb-deployment-hostpath-xxxx-yyyy)
```
kubectl exec -it mariadb-deployment-hostpath-d77585f54-b8vqn -- mariadb -u root -p
```
#### 비밀번호는 mariadb-secret-hostpath에 설정한 '1004' 입니다.

#### 데이터베이스 생성 및 사용
```
USE kosa_db;
CREATE TABLE users (id INT AUTO_INCREMENT PRIMARY KEY, name VARCHAR(255));
INSERT INTO users (name) VALUES ('Charlie'), ('David');
SELECT * FROM users;
# exit;
```
   2. 파드 삭제 후 영속성 확인:
      MariaDB 파드를 강제로 삭제하여 파드가 재스케줄링되도록 합니다.
```
# MariaDB 파드 이름 확인
kubectl get pods -l app=mariadb-hostpath

# 파드 삭제
kubectl delete pod <YOUR_MARIADB_POD_NAME>
```
      잠시 후, 새로운 MariaDB 파드가 다시 Running 상태가 될 것입니다.
```
kubectl get pods -l app=mariadb-hostpath
```
      새로 생성된 MariaDB 파드에 다시 접속하여 이전에 생성했던 데이터가 그대로 남아있는지 확인합니다.
```
# 새로운 MariaDB 파드 이름 확인
kubectl get pods 

# 새로운 파드에 접속
kubectl exec -it <NEW_MARIADB_POD_NAME> -- mariadb -u root -p
# 비밀번호 입력

# 데이터 확인
USE kosa_db;
SELECT * FROM users;
# exit;
```

이전에 입력했던 'Charlie'와 'David' 데이터가 그대로 출력된다면, hostPath PV/PVC를 통한 MariaDB 데이터의 영속성이 성공적으로 작동하는 것입니다.

이 예제는 hostPath PV/PVC가 어떻게 작동하는지 보여주지만, 앞서 강조했듯이 프로덕션 환경에서는 사용하지 않도록 주의해야 합니다.

