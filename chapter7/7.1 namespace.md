## 네임스페이스(Namespace)란?

  네임스페이스는 하나의 물리적인 쿠버네티스 클러스터를 여러 개의 논리적인 가상 클러스터처럼 나누어
  사용하는 기능입니다.

  컴퓨터의 폴더(디렉터리)와 비슷하다고 생각하면 쉽습니다. A폴더에 있는 file.txt와 B폴더에 있는 file.txt가
  이름은 같지만 서로 다른 파일인 것처럼, A네임스페이스의 my-pod와 B네임스페이스의 my-pod는 이름이 같아도
  완전히 별개의 리소스로 취급됩니다.

  주요 사용 목적:

   1. 리소스 격리 및 이름 관리: 여러 팀이나 프로젝트가 하나의 클러스터를 사용할 때, 리소스(파드, 서비스 등)의
      이름이 충돌하는 것을 방지합니다.
   2. 접근 제어(RBAC): 특정 사용자나 그룹에게 특정 네임스페이스에 대한 권한만 부여하여 보안을 강화할 수
      있습니다. (예: '개발팀'은 'dev' 네임스페이스에만 접근 가능)
   3. 리소스 할당량(Quota) 관리: 네임스페이스별로 사용할 수 있는 CPU, 메모리 등의 자원 양을 제한하여 한 팀이
      클러스터의 모든 자원을 독점하는 것을 막을 수 있습니다.

  ---

## 네임스페이스 기본 명령어 및 사용법

1. 네임스페이스 조회
  

    ```
    kubectl get ns
   
    kubectl get namespace 
    ```

    쿠버네티스를 설치하면 기본적으로 몇 개의 네임스페이스가 생성됩니다.

   * default: 사용자가 네임스페이스를 지정하지 않으면 모든 리소스는 여기에 생성됩니다.
   * kube-system: 쿠버네티스 시스템 자체의 핵심 컴포넌트(Control Plane 등)들이 실행되는 공간입니다. 절대 이
     곳의 리소스를 직접 수정하거나 삭제하면 안 됩니다.
   * kube-public: 모든 사용자(인증되지 않은 사용자 포함)가 읽을 수 있는 데이터를 저장하는 공간입니다.
   * kube-node-lease: 각 노드의 임대(lease) 객체를 저장하여 노드의 상태를 확인하는 데 사용됩니다.


2. 네임스페이스 생성
  
    두 가지 방법이 있습니다.

  방법 A: 명령어로 직접 생성 (간편한 방법)
  방법 B: YAML 파일로 생성 (권장되는 방법)
  

  ### 방법 A: 명령어로 직접 생성 (간편한 방법)
   'dev' 라는 이름의 네임스페이스 생성

```    
kubectl create namespace dev
```


  ### 방법 B: YAML 파일로 생성 (권장되는 방법)
  dev-namespace.yaml 파일을 하나 만듭니다.
```
   vi dev-namespace.yaml
   
   apiVersion: v1
   kind: Namespace
   metadata:
     name: dev
```

  그 다음 아래 명령어로 파일을 클러스터에 적용합니다.
```
kubectl apply -f dev-namespace.yaml
```
  > Tip: YAML 파일을 사용하면 설정을 파일로 관리하고 Git 등으로 버전을 추적할 수 있어 더 체계적입니다.

3. 특정 네임스페이스에 리소스 생성하기

    파드, 디플로이먼트 등을 만들 때 YAML 파일의 metadata 섹션에 namespace를 지정하면 됩니다.

  예제: `dev` 네임스페이스에 Nginx 파드 생성하기
  my-pod.yaml 파일을 작성합니다.
```
# my-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-nginx
  namespace: dev  # <-- 여기에 'dev' 네임스페이스를 지정!
  labels:
    app: nginx
spec:
  containers:
  - name: nginx
    image: nginx:latest
    ports:
    - containerPort: 80
```
  이제 이 파일을 적용하면 dev 네임스페이스에 파드가 생성됩니다.
```
kubectl apply -f my-pod.yaml
```

4. 특정 네임스페이스의 리소스 조회하기
  
    kubectl 명령어에 -n 또는 --namespace 옵션을 사용합니다.
```
# 'dev' 네임스페이스의 모든 파드 조회
kubectl get pods -n dev

# 'production' 네임스페이스의 모든 디플로이먼트 조회
kubectl get deployments --namespace=production

# 만약 -n 옵션을 생략하면 'default' 네임스페이스에서 조회합니다.
kubectl get pods
```

5. 현재 작업할 기본 네임스페이스 변경하기
  매번 -n 옵션을 쓰는 것이 번거롭다면, 현재 컨텍스트(context)의 기본 네임스페이스를 변경할 수 있습니다.
```
# 앞으로의 모든 kubectl 명령이 'dev' 네임스페이스를 기본으로 사용하도록 설정
kubectl config set-context --current --namespace=dev

# 이제 -n 옵션 없이도 'dev' 네임스페이스의 파드가 조회됨
kubectl get pods

# 앞으로의 모든 kubectl 명령이 'default' 네임스페이스를 기본으로 사용하도록 설정
kubectl config set-context --current --namespace=default

```
  ---

6. 네임스페이스 삭제하기 

  매우 강력하고 위험할 수 있으니, 아래 경고 문구를 반드시 먼저 읽어보신 후 진행해주세요.

  ⚠️ 매우 중요한 경고

   * 모든 것이 삭제됩니다: 네임스페이스를 삭제하면, 그 안에 포함된 모든 리소스가 영구적으로 삭제됩니다. (Pod, Deployment, Service, ConfigMap, Secret, PVC 등 모든 것)
   * 되돌릴 수 없습니다: 이 작업은 한번 실행하면 되돌릴 수 없습니다. 삭제하기 전에 중요한 데이터나 설정은 반드시 백업해야 합니다.
   * 이름을 다시 확인하세요: 삭제하려는 네임스페이스의 이름이 정확한지 두 번, 세 번 확인하세요. 실수로 다른 네임스페이스를 삭제하는 것을 방지해야 합니다.
   * 시스템 네임스페이스는 절대 금지: default, kube-system, kube-public과 같은 쿠버네티스 시스템 네임스페이스는 절대로 삭제하면 안 됩니다. 클러스터 전체가 망가질 수 있습니다.

  ---

1 기본 삭제 명령어

  가장 기본적인 삭제 명령어는 다음과 같습니다.
```
# <삭제할-네임스페이스-이름> 을 실제 이름으로 바꿔서 실행하세요.
kubectl delete namespace <삭제할-네임스페이스-이름>

# 예시: 'dev' 네임스페이스를 삭제하는 경우
kubectl delete namespace dev
```
  이 명령을 실행하면 쿠버네티스는 해당 네임스페이스를 Terminating (종료 중) 상태로 바꾸고, 그 안의 모든 리소스를 순차적으로 삭제하기 시작합니다. 모든 내부 리소스가 성공적으로 삭제되어야만 네임스페이스가
  최종적으로 사라집니다.

  ---

2 문제 해결: 네임스페이스가 Terminating 상태에서 멈춘 경우

  가끔 kubectl get ns를 실행했을 때, 네임스페이스가 삭제되지 않고 계속 Terminating 상태로 남아있는 경우가
  있습니다.

  주요 원인:
  네임스페이스 안에 있는 특정 리소스가 완전히 삭제되지 못했기 때문입니다. 보통 해당 리소스를 제어하는 컨트롤러가 응답이 없거나, 리소스에 finalizer(파이널라이저)라는 '삭제 방지 꼬리표'가 붙어 있어서 삭제가
  보류되는 경우에 발생합니다.

  해결 방법 (강제 삭제)

  이 방법은 최후의 수단이며, 왜 네임스페이스가 멈췄는지 원인을 모를 경우 예기치 않은 부작용이 발생할 수 있습니다. 신중하게 사용해야 합니다.

   1. 멈춰있는 네임스페이스의 상세 정보 확인 (JSON 형식)
      먼저 멈춰있는 네임스페이스의 설정을 JSON 파일로 저장합니다.
```
# <멈춰있는-네임스페이스>를 실제 이름으로 변경
kubectl get namespace <멈춰있는-네임스페이스> -o json > temp_namespace.json
```
   2. `finalizers` 항목 제거
      방금 저장한 temp_namespace.json 파일을 텍스트 편집기로 엽니다.
      파일 내용 중에 spec 섹션 아래에 있는 finalizers 부분을 찾아서 해당 라인을 완전히 삭제합니다.

      수정 전 예시:
```
{
    "apiVersion": "v1",
    "kind": "Namespace",
    "metadata": { ... },
    "spec": {
        "finalizers": [  // <-- 이 부분
            "kubernetes" // <-- 이 부분을 모두 삭제
        ]                // <-- 이 부분
    },
     "status": { ... }
 }
```
      수정 후:
```
{
    "apiVersion": "v1",
    "kind": "Namespace",
    "metadata": { ... },
    "spec": {
    },
    "status": { ... }
}
```
      spec 안에 finalizers 배열 자체를 깨끗하게 지우고 파일을 저장합니다.

   3. 쿠버네티스 API 프록시 실행
      수정된 파일을 적용하기 위해, 새 터미널 창을 하나 더 열고 아래 명령어로 API 프록시를 실행합니다. 이 프록시는 내 컴퓨터에서 쿠버네티스 API 서버로 직접 통신할 수 있는 통로를 열어줍니다.
```
kubectl proxy
# Starting to serve on 127.0.0.1:8001 프록시가 실행된 터미널은 그대로 둡니다.
```
    `finalizer`가 제거된 설정으로 덮어쓰기 원래 작업하던 터미널 창으로 돌아와서, 아래 curl 명령어를 실행하여 finalizer가 제거된 temp_namespace.json 파일의 내용으로 API 서버에 직접 요청을 보냅니다.
```
# <멈춰있는-네임스페이스>를 실제 이름으로 변경
curl -k -H "Content-Type: application/json" -X PUT --data-binary @temp_namespace.json
http://127.0.0.1:8001/api/v1/namespaces/<멈춰있는-네임스페이스>/finalize
```
  이 명령을 실행하면 finalizer가 제거되어 쿠버네티스가 더 이상 해당 네임스페이스의 삭제를 보류하지 않고,
  Terminating 상태가 끝나면서 네임스페이스가 완전히 삭제됩니다. 작업이 끝나면 kubectl proxy를 실행했던
  터미널은 Ctrl + C로 종료하면 됩니다.


### 주요 사용 사례 (Best Practices)

  사례 1: 환경별 분리 (가장 일반적)
  개발, 스테이징, 운영 환경을 네임스페이스로 분리합니다.
   * dev: 개발 환경
   * staging: 운영 환경에 배포하기 전 테스트하는 환경
   * production: 실제 사용자가 사용하는 운영 환경

  이렇게 하면 각 환경의 애플리케이션이 서로 영향을 주지 않고 독립적으로 관리될 수 있습니다.

  사례 2: 팀/조직별 분리
  클러스터를 여러 팀이 함께 사용할 때 팀별로 네임스페이스를 할당합니다.
   * frontend-team
   * backend-team
   * database-team

  여기에 RBAC(역할 기반 접근 제어)를 적용하여 frontend-team은 자신의 네임스페이스에만 쓰기/수정 권한을
  갖도록 제한할 수 있습니다.

  사례 3: 애플리케이션/서비스별 분리
  클러스터 공통으로 사용되는 특정 애플리케이션 스택을 별도의 네임스페이스로 묶습니다.
   * monitoring: 프로메테우스, 그라파나 등 모니터링 도구들을 설치
   * logging: EFK(Elasticsearch, Fluentd, Kibana) 스택 등 로그 수집 시스템을 설치
   * ingress-nginx: Ingress Controller를 설치


### 네임스페이스 간 통신

  기본적으로 한 네임스페이스의 파드는 다른 네임스페이스의 서비스에 접근할 수 있습니다. 이때 서비스의
  주소를 <서비스이름>.<네임스페이스이름> 형식으로 사용하면 됩니다.

  예를 들어, frontend 네임스페이스의 파드가 backend 네임스페이스에 있는 api-server라는 서비스에 접근하려면
  아래 주소를 사용합니다.

```
http://api-server.backend
```
