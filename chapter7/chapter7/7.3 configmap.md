### ConfigMap이란?

  ConfigMap은 설정(Configuration) 데이터를 키-값(key-value) 쌍으로 저장하는 쿠버네티스 오브젝트입니다.
  애플리케이션 코드나 컨테이너 이미지로부터 설정을 분리하여, 애플리케이션을 다시 빌드하지 않고도 설정을 쉽게
   변경하고 관리할 수 있게 해줍니다.

  주요 특징 및 사용 목적:

   * 설정 분리: 데이터베이스 주소, 외부 API 엔드포인트, 기능 플래그(feature flag) 등의 설정을 이미지와
     분리하여 관리합니다.
   * 환경 이식성: 동일한 애플리케이션 이미지를 dev, staging, production 등 여러 환경에 배포할 때, 각 환경에
     맞는 ConfigMap만 바꿔서 적용하면 되므로 이식성이 높아집니다.
   * 중앙 관리: 설정을 쿠버네티스 오브젝트로 관리하므로, 파드나 서비스처럼 YAML로 선언하고 버전 관리를 할 수
     있습니다.

  > ⚠️ 중요: ConfigMap은 민감하지 않은 일반 설정 데이터를 위해 설계되었습니다. 데이터베이스 비밀번호, API 키,
   TLS 인증서와 같은 민감한 정보는 반드시 Secret(시크릿) 오브젝트에 저장해야 합니다.

  ---

### ConfigMap 생성 방법

  ConfigMap을 생성하는 방법은 크게 3가지가 있습니다.

  1. `literal`(리터럴) 값으로 직접 만들기  
  2. 파일로부터 만들기
  3. YAML 파일로 선언하여 만들기 (가장 권장)

 
  방법 1: `literal`(리터럴) 값으로 직접 만들기


  간단한 키-값 데이터를 명령어로 직접 생성할 때 유용합니다.

```
kubectl create configmap my-app-config \
  --from-literal=app.mode=production \
  --from-literal=app.version=1.5
```
  결과 확인:
```
# 생성된 ConfigMap을 YAML 형식으로 확인

kubectl get configmap my-app-config -o yaml

출력결과 

apiVersion: v1
kind: ConfigMap
metadata:
  name: my-app-config
data:
  app.mode: production
  app.version: "1.5"
```

  방법 2: 파일로부터 만들기

  기존에 사용하던 설정 파일을 그대로 ConfigMap으로 만들 때 매우 유용합니다. 파일 이름이 key가 되고, 파일
  내용이 value가 됩니다.

   1. 설정 파일 준비
```
echo "production" > app.mode
echo "user=admin" > app.properties
ls 
```
   2. 파일로부터 ConfigMap 생성
```
kubectl create configmap my-app-config-from-file \
  --from-file=app.mode \
  --from-file=app.properties
```

결과 확인:
```
kubectl get configmap my-app-config -o yaml

출력결과 

apiVersion: v1
data:
  app.mode: |          # <- 생성된 키 
    production
  app.properties: |    # <- 생성된 키 
    user=admin
kind: ConfigMap
metadata:
  creationTimestamp: "2025-08-23T05:37:48Z"
  name: my-app-config-from-file
  namespace: default
  resourceVersion: "142308"
  uid: ef85a5dc-c690-455c-a56e-a076a15391a6
```

  app.mode와 app.properties라는 두 개의 키가 생성된 것을 볼 수 있습니다.


  방법 3: YAML 파일로 선언하여 만들기 (가장 권장)

  설정을 파일로 명확하게 선언하고 Git 등으로 버전 관리를 할 수 있어 가장 권장되는 방법입니다.

   `my-nginx-config.yaml` 파일 작성
      data 필드 아래에 원하는 키-값 쌍을 정의합니다. 값에 여러 줄의 텍스트가 필요하면 |를 사용합니다.
```
# vi my-nginx-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-nginx-config
data:
  # 방법 1: 일반적인 키-값
  app.name: "내가 만든 앱의 제목"

  # 방법 2: 파일 내용처럼 여러 줄의 텍스트 저장
  nginx.conf: |
    server {
        listen 80;
        server_name example.com;
        root /var/www/html;
        index index.html;
    }
```

   YAML 파일 적용
```
kubectl apply -f my-nginx-config.yaml
```
  ---

  3. 파드(Pod)에서 ConfigMap 사용하기

  생성한 ConfigMap을 파드에서 사용하는 방법은 크게 3가지가 있습니다.

  방법 1: 환경 변수(Environment Variable)로 주입

  ConfigMap의 특정 key 값을 파드의 환경 변수로 주입하는 방식입니다.

```
# vi pod-with-env.yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod-1
spec:
  containers:
    - name: my-container
      image: busybox
      command: 
        - /bin/sh
        - -c
        - |
          env # 컨테이너의 모든 환경 변수 출력
          echo "--- sleep 1시간 기다림 ---"
          sleep 3600
      env:
        - name: APP_NAME_IN_POD # 파드에서 사용할 환경 변수 이름
          valueFrom:
            configMapKeyRef:
              name: my-nginx-config # 사용할 ConfigMap 이름
              key: app.name         # 사용할 ConfigMap의 key


# 환경 변수를 my-nginx-config.yaml 파일을 실행해서 ConfigMap을 만들고
# kubectl apply -f my-nginx-config.yaml
# 해당 파일을 파드로 실행항여 결과를 확인 한다 
# kubectl apply -f pod-with-env.yaml
# 로그을 확인한다 
# kubectl logs my-pod-1
# 환경 변수가 잘 설정되었는지 확인
# 파드 내부로 진입하여 환경설정 외에 확인하고 싶은 것을 확인한다
# kubectl exec -it my-pod-1 -- /bin/sh
# echo $APP_NAME_IN_POD

```
실행방법 
```
kubectl apply -f pod-with-env.yaml
```

  방법 2: ConfigMap의 모든 데이터를 환경 변수로 주입

  
  2개의 환경변수 yaml 을 생성한다 

```
#vi log-level-configmap.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: log-level-configmap
data:
  # 방법 1: 일반적인 키-값
  LOG_LEVEL: INFO

```

```
#vi start-k8s.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: start-k8s
data:
  container: docker
  k8s: kubernetes


```

두개의 환경변수 파일을 실행합니다

```
kubectl apply -f log-level-configmap.yaml
kubectl apply -f start-k8s.yaml

```

configmap 목록을 확인합니다 

```
kubectl get configmap 

```

configmap 의 상세내용을 확인합니다 

```
kubectl describe configmap log-level-configmap

```

configmap 의 상세내용을 확인합니다 

```
kubectl describe configmap log-level-configmap

```

yaml 파일로 configmap 결과 확인 
```
kubectl get configmap log-level-configmap -o yaml
```

  ConfigMap에 있는 모든 키-값 쌍을 한 번에 환경 변수로 만들 때 사용합니다.

```
# pod-with-envfrom.yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod-2
spec:
  containers:
    - name: my-container
      image: busybox
      command: 
        - /bin/sh
        - -c
        - |
          env # 컨테이너의 모든 환경 변수 출력
          echo "--- sleep 1시간 기다림 ---"
          sleep 3600
      envFrom:
        - configMapRef:
            name: my-nginx-config  # 이 ConfigMap의 모든 키가 환경 변수 이름이 됨
        - configMapRef:
            name: log-level-configmap  # 이 ConfigMap의 모든 키가 환경 변수 이름이 됨
        - configMapRef:
            name: start-k8s  # 이 ConfigMap의 모든 키가 환경 변수 이름이 됨
```
yaml 파일을 파드로 실행하여 결과 확인합니다 

```
pod-with-envfrom.yaml
```

컨테이너 실행 로그 확인 
```
kubectl logs my-pod-2
```


  방법 3: 볼륨(Volume)으로 마운트하여 파일처럼 사용 (가장 많이 사용)

  ConfigMap의 데이터를 파일처럼 컨테이너의 특정 경로에 마운트하는 방식입니다. nginx.conf와 같이 파일
  자체가 필요한 설정에 매우 유용합니다.

```
# pod-with-volume.yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod-3
spec:
  containers:
    - name: my-container
      image: busybox
      command: 
        - /bin/sh
        - -c
        - |
          echo -e "\n--- 파일 목록 ---"
          ls /etc/config
          echo -e "\n\n/etc/config/app.name 파일 내용 출력 "
          cat /etc/config/app.name
          echo -e "\n\n/etc/config/nginx.conf 파일 내용 출력 "
          cat /etc/config/nginx.conf
          echo -e "\n\n:--- sleep 1시간 기다림 ---"
          sleep 3600      
      # 마운트된 경로의 파일 목록 확인
      volumeMounts:
      - name: config-volume
        mountPath: /etc/config # 컨테이너 내부의 이 경로에 파일들이 생성됨
  volumes:
    - name: config-volume
      configMap:
        name: my-nginx-config # 사용할 ConfigMap 이름
```
   
  위 예제를 실행하면, my-pod-3 컨테이너의 /etc/config 디렉터리 안에 app.name과 nginx.conf라는 두 개의
  파일이 생성된 것을 확인할 수 있습니다.

  ---

  4. ConfigMap 업데이트와 적용

   * kubectl edit configmap <이름> 또는 kubectl apply -f <파일>로 ConfigMap을 업데이트할 수 있습니다.
   * 주의: ConfigMap을 업데이트해도, 이미 실행 중인 파드에 자동으로 변경 내용이 반영되지 않습니다.
       * 볼륨 마운트의 경우: kubelet이 주기적으로 변경을 감지하여 마운트된 파일을 업데이트하지만, 실시간이 아니며 애플리케이션이 파일을 다시 읽지 않으면 소용이 없습니다.
       * 환경 변수의 경우: 파드가 재시작되기 전까지 절대 변경되지 않습니다.
   * Best Practice: ConfigMap 변경을 파드에 안정적으로 적용하는 가장 좋은 방법은 디플로이먼트(Deployment)를
     재시작(rollout restart)하여 파드를 새로 생성하는 것입니다.

 ConfigMap의 변경 사항을 Deployment에 안정적으로 적용하는 가장 좋은 방법인 "rollout restart"에 대한 전체 예제를 단계별로 같이 만들어 보겠습니다.

  수동으로 재시작하는 간편한 방법과, CI/CD 파이프라인 등에서 자동화하기 좋은 고급 기법 세 가지를 모두 만들어 보겠습니다.

  반드시 이전 작업한 모든 ConfigMap, Deployment, Service, Pod를 종료하고 진행합니다 


  ---

  배경 시나리오

  간단한 Nginx 웹서버를 배포하고, ConfigMap을 이용해 환영 메시지를 동적으로 변경하는 상황을
  가정하겠습니다.

  1단계: 최초 배포 (Initial Deployment : step1)

  먼저 필요한 파일 3개(ConfigMap, Deployment, Service)를 준비합니다.

  configmap.yaml  애플리케이션의 설정을 정의합니다.
```
vi configmap.yaml

apiVersion: v1
kind: ConfigMap
metadata:
  name: my-app-config
data:
  GREETING: "Hello"
  MESSAGE: "World"
```

  deployment.yaml 파일은 Nginx를 실행하고, 시작 시점에 ConfigMap의 환경 변수를 읽어 index.html 파일을 생성하는 디플로이먼트입니다.
```
vi deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: web-server
        image: nginx:1.25
        ports:
        - containerPort: 80
        envFrom:
        - configMapRef:
            name: my-app-config # 위에서 만든 ConfigMap을 참조
        # 컨테이너 시작 시, 환경변수를 읽어 index.html 파일을 동적으로 생성
        command: ["/bin/sh", "-c"]
        args:
          - |
            echo "<html><body><h1>$GREETING, $MESSAGE</h1></body></html>" >
      /usr/share/nginx/html/index.html;
            nginx -g 'daemon off;';
```

  service.yaml 파일은 디플로이먼트를 외부에서 접근할 수 있도록 서비스를 생성합니다. (테스트를 위해 NodePort 타입 사용)
```
vi service.yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: NodePort # 로컬 환경에서 테스트하기 쉬운 NodePort 타입 사용
```

  실행:
  위 3개의 파일을 한 폴더에 저장하고 아래 명령어로 한 번에 배포합니다.
   
```
kubectl apply -f .

kubectl get service -o wide
```

결과 예시
```
NAME             TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE     SELECTOR
kubernetes       ClusterIP   10.96.0.1      <none>        443/TCP        3d23h   <none>
my-app-service   NodePort    10.106.70.38   <none>        80:31242/TCP   49s     app=my-app
```

  확인:
  서비스의 NodePort를 확인하고, http://<노드IP>:<NodePort>로 접속하여 "Hello, World"가 잘 보이는지 확인합니다.

```
curl 10.106.70.38
curl 192.168.80.159:31242
```

  ---

  2단계: ConfigMap 변경 (step2)

  이제 환영 메시지를 한국어로 바꿔보겠습니다.

  configmap.yaml 파일을 아래와 같이 수정합니다.
```
vi configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: my-app-config
data:
  GREETING: "안녕하세요" # 변경
  MESSAGE: "쿠버네티스" # 변경
```
  변경된 ConfigMap 적용:
```   
kubectl apply -f configmap.yaml

curl 10.106.70.38
curl 192.168.80.159:31242

```

  문제점 확인:
  이 상태에서 다시 웹페이지에 접속해 보면, 여전히 "Hello, World"가 보입니다. 기존에 실행된 파드들은 변경된 ConfigMap의 내용을 모르기 때문입니다.

  ---

  3. 변경사항 적용하기 (Rollout Restart)

  이제 이 변경사항을 파드에 적용하는 두 가지 방법을 알아보겠습니다.

  방법 A: 수동으로 재배포 실행 (가장 간단한 방법)

  가장 직관적이고 간단한 방법입니다. kubectl 명령어를 통해 디플로이먼트의 모든 파드를 점진적으로(rolling)
  재시작하도록 직접 지시합니다.

```
kubectl rollout restart deployment my-app-deployment
```

  동작 원리:
  이 명령은 디플로이먼트의 파드들을 하나씩 안전하게 종료하고 새로 생성합니다. 새로 생성되는 파드들은 시작 시점에 변경된 최신 ConfigMap의 내용을 읽어오게 됩니다.

  확인:
```
curl 10.106.70.38
curl 192.168.80.159:31242
```

  재배포가 완료된 후 (kubectl rollout status deployment/my-app-deployment로 확인 가능) 다시 웹페이지에
  접속하면, 이제 "안녕하세요, 쿠버네티스" 라는 변경된 메시지가 보이게 됩니다.

  방법 B: 체크섬(Checksum)을 이용한 자동 재배포 (고급 기법/자동화) (step3)

  이 방법은 ConfigMap이 변경될 때마다 디플로이먼트의 템플릿(template)에 작은 변화를 주어, 쿠버네티스가 "템플릿이 변경되었으니 재배포해야 한다"고 자동으로 인지하게 만드는 영리한 방법입니다. 주로 CI/CD 파이프라인에서 사용됩니다.

   ConfigMap의 내용으로 체크섬(해시값) 생성: 먼저, 현재 my-app-config의 내용으로 고유한 해시값을 생성합니다.

```  
#Linux / macOS
checksum=$(kubectl get configmap my-app-config -o yaml | sha256sum | awk '{print $1}')
```
   생성된 체크섬을 Deployment에 Annotation으로 추가(Patch):
      kubectl patch 명령어를 사용하여 디플로이먼트의 파드 템플릿(spec.template)에 방금 생성한 체크섬을 annotation으로 추가합니다.

```
kubectl patch deployment my-app-deployment -p \
  '{"spec":{"template":{"metadata":{"annotations":{"checksum/config": "'$checksum'"}}}}}'
```
  동작 원리:
   * configmap.yaml의 내용이 바뀌면, 1번 단계에서 생성되는 checksum 값도 완전히 달라집니다.
   * 2번 단계의 patch 명령은 디플로이먼트의 annotation 값을 새로운 checksum으로 변경합니다.
   * 쿠버네티스는 spec.template 부분(annotation 포함)이 변경된 것을 감지하고, 이를 템플릿의 변경으로
     간주하여 자동으로 롤링 업데이트를 시작합니다.

  방법 A와 마찬가지로, 자동으로 재배포가 일어나고 잠시 후 웹페이지에 접속하면 변경된 내용이 반영됩니다. 
  ConfigMap 변경부터 체크섬 생성, 그리고 Deployment 패치까지의 과정을 자동화하는 셸 스크립트(Shell Script)를 만들어 보겠습니다.

  이 스크립트는 CI/CD 파이프라인에 통합하거나, 수동으로 변경사항을 적용할 때 실수를 줄여주는 매우 유용한 도구가 될 수 있습니다.

