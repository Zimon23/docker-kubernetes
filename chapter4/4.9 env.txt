Docker Compose에서 환경 변수를 사용하는 방법

Docker Compose에서 환경 변수를 사용하는 방법을 단계별로 설명하고, FastAPI와 MariaDB를 사용하여 세 가지 구체적인
  예제를 통해 점진적으로 개선하는 과정을 보여드리겠습니다.

  환경 변수 사용의 중요성

  애플리케이션을 개발하고 배포할 때, 데이터베이스 접속 정보, API 키 등과 같은 설정 값들은 코드와 분리하여 관리하는 것이
  매우 중요합니다. 환경 변수를 사용하면 다음과 같은 이점을 얻을 수 있습니다.

   * 보안: 민감한 정보를 코드에 직접 하드코딩하지 않아 소스 코드 노출 시에도 안전합니다.
   * 유연성: 개발, 테스트, 프로덕션 환경마다 다른 설정 값을 쉽게 적용할 수 있습니다.
   * 관리 용이성: 설정 변경 시 코드를 수정하고 다시 빌드할 필요 없이 컨테이너 재시작만으로 변경 사항을 적용할 수 있습니다.

  이제 세 단계에 걸쳐 예제를 만들어 보겠습니다.

  1단계: docker-compose.yml에 환경 변수 직접 작성하기

  가장 기본적인 방법으로, docker-compose.yml 파일 내에 environment 키를 사용하여 환경 변수를 직접 정의합니다.

  프로젝트 구조

   ──env_example_step1/
     ├───docker-compose.yml
     └───backend/
         ├───main.py
         ├───Dockerfile
         └───requirements.txt

   * `backend/main.py`: FastAPI 애플리케이션입니다. os.getenv() 함수를 사용하여 DB_HOST, DB_USER, DB_PASSWORD, DB_NAME
     환경 변수를 읽어와 데이터베이스에 연결합니다.
   * `docker-compose.yml`:
       * backend 서비스의 environment 섹션에 API 서버가 사용할 환경 변수들을 직접 키-값 형태로 정의했습니다.
       * db 서비스의 environment 섹션에는 MariaDB 컨테이너를 초기화하는 데 필요한 환경 변수(MYSQL_ROOT_PASSWORD 등)를
         설정했습니다.

  실행 방법

   1. 터미널을 열고 env_example_step1 디렉터리로 이동합니다.
   2. 아래 명령어를 실행하여 컨테이너를 빌드하고 실행합니다.

     docker compose up --build
      
   3. 웹 브라우저나 새로운 터미널에서 curl을 사용하여 http://localhost:8000/db_check에 접속하면 
      실행 로그 출력 화면에서 데이터베이스 연결 성공 메시지를 확인할 수 있습니다.
    
    curl http://localhost:8000/db_check 

   4. backend 로그가 출력을 확인합니다 

backend-1  | INFO:     Application startup complete.
backend-1  | INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
backend-1  | 데이터베이스 연결을 시도합니다...
backend-1  | 데이터베이스 연결 실패: 2003 (HY000): Can't connect to MySQL server on 'db:3306' (111)
backend-1  | 데이터베이스 연결을 시도합니다...
backend-1  | 데이터베이스 연결 실패: 2003 (HY000): Can't connect to MySQL server on 'db:3306' (111)
backend-1  | 데이터베이스 연결을 시도합니다...
backend-1  | 데이터베이스 연결에 성공했습니다!
backend-1  | 테이블이 없는 경우 생성합니다...
backend-1  | 'items' 테이블이 준비되었습니다.
backend-1  | 데이터베이스 연결을 시도합니다...
backend-1  | 데이터베이스 연결에 성공했습니다!
backend-1  | INFO:     172.22.0.1:49374 - "GET /db_check HTTP/1.1" 200 OK


  문제점

  이 방법은 간단하지만, 민감한 정보(DB 비밀번호 등)가 `docker-compose.yml` 파일에 그대로 노출됩니다. 
  이 파일은 보통 버전 관리 시스템(Git 등)에 포함되므로, 보안상 매우 취약합니다.

  2단계: .env 파일을 사용하여 환경 변수 관리하기

  1단계의 문제점을 개선하기 위해, 환경 변수를 별도의 .env 파일로 분리합니다. Docker Compose는 실행될 때 자동으로 현재
  디렉터리의 .env 파일을 읽어 docker-compose.yml 파일 내에서 변수처럼 사용할 수 있게 해줍니다.

  프로젝트 구조

  1단계와 거의 동일하며, 루트에 .env 파일만 추가됩니다.

   ──env_example_step2/
     ├───.env       #중요 : 새로 추가된 파일 
     ├───.gitignore #중요 : 새로 추가된 파일 
     ├───docker-compose.yml
     └───backend/
         ├───main.py
         ├───Dockerfile
         └───requirements.txt

  설명

   * `.env`: 환경 변수들을 KEY=VALUE 형식으로 저장합니다. 
     이 파일은 `.gitignore`에 추가하여 Git 저장소에 올라가지 않도록 반드시 설정해야 합니다.
   * `docker-compose.yml`:
       * environment 섹션의 값들이 ${VARIABLE_NAME} 형태로 변경되었습니다.
       * docker-compose는 이 파일을 파싱할 때 .env 파일에서 해당 변수 값을 찾아 치환합니다.

  실행 방법

   1. 터미널에서 env_example_step2 디렉터리로 이동합니다.
      cd env_example_step2
      
   2. docker compose up --build 명령어를 실행합니다.
   
   3. 웹 브라우저나 새로운 터미널에서 curl을 사용하여 http://localhost:8001/db_check에 접속하면 
      실행 로그 출력 화면에서 데이터베이스 연결 성공 메시지를 확인할 수 있습니다.
    
    curl http://localhost:8001/db_check 

   4. backend 로그가 출력을 확인합니다 

backend-1  | INFO:     Application startup complete.
backend-1  | INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
backend-1  | 데이터베이스 연결을 시도합니다...
backend-1  | 데이터베이스 연결 실패: 2003 (HY000): Can't connect to MySQL server on 'db:3306' (111)
backend-1  | 데이터베이스 연결을 시도합니다...
backend-1  | 데이터베이스 연결 실패: 2003 (HY000): Can't connect to MySQL server on 'db:3306' (111)
backend-1  | 데이터베이스 연결을 시도합니다...
backend-1  | 데이터베이스 연결에 성공했습니다!
backend-1  | 테이블이 없는 경우 생성합니다...
backend-1  | 'items' 테이블이 준비되었습니다.
backend-1  | 데이터베이스 연결을 시도합니다...
backend-1  | 데이터베이스 연결에 성공했습니다!
backend-1  | INFO:     172.22.0.1:49374 - "GET /db_check HTTP/1.1" 200 OK


  문제점

  이 방법은 설정과 코드를 분리하여 1단계보다 발전했지만, 여전히 `.env` 파일이 일반 텍스트(plaintext)로 디스크에 저장된다는
  근본적인 문제가 있습니다. 만약 서버의 파일 시스템에 접근 권한을 탈취당하면 모든 민감한 정보가 그대로 노출됩니다.


  3단계: Docker Secrets를 사용하여 민감 정보 암호화 및 관리하기

  가장 안전하고 권장되는 방법입니다. Docker Secrets는 민감한 데이터를 관리하기 위해 Docker가 제공하는 공식 기능입니다.
  Secret은 Docker Swarm이나 Docker Compose에 의해 관리되며, 컨테이너 내부의 특정 경로(/run/secrets/<secret_name>)에 파일
  형태로 마운트됩니다. 환경 변수로 노출되지 않아 docker inspect 같은 명령어로도 내용을 확인할 수 없습니다.

  프로젝트 구조

  민감한 정보를 담을 secrets 디렉터리를 추가합니다.

   ───env_example_step3/
      ├───.gitignore         #(중요 : 수정된 파일)
      ├───docker-compose.yml
      ├───backend/
      │   ├───main.py        #(중요 : 수정된 파일)
      │   ├───Dockerfile
      │   └───requirements.txt
      └───secrets/           #(중요 : 추가된 폴더)
          ├───db_password.txt
          └───db_root_password.txt

  설명

   * `secrets/`: db_password.txt와 db_root_password.txt 파일에 각각의 비밀번호를 줄바꿈 없이 저장합니다. 
      이 디렉터리 역시 .gitignore에 추가해야 합니다.
   * `backend/main.py`:
       * get_secret() 함수가 추가되었습니다. 이 함수는 컨테이너 내의 /run/secrets/<secret_name> 경로에서 파일을 읽어 그
         내용을 반환합니다.
       * get_db_connection() 함수가 os.getenv("DB_PASSWORD") 대신 get_secret('db_password')를 호출하여 비밀번호를
         가져오도록 수정되었습니다.
   * `docker-compose.yml`:
       * 최상위에 secrets 섹션이 추가되었습니다. 여기서 사용할 secret들의 이름과 실제 파일 경로를 정의합니다.
       * 각 서비스(backend, db)에는 secrets 키를 사용하여 이 서비스가 어떤 secret을 사용할지 명시합니다.
       * `db` 서비스: MariaDB 이미지는 MYSQL_PASSWORD_FILE과 같은 특별한 환경 변수를 지원합니다. 여기에 secret 파일
         경로(/run/secrets/db_password)를 지정하면, MariaDB가 직접 파일 내용을 읽어 비밀번호로 사용합니다.
       * `backend` 서비스: environment에서 DB_PASSWORD가 제거되고, 대신 secrets 목록에 db_password가 추가되었습니다. 이제
         FastAPI 앱은 파일 시스템에서 직접 비밀번호를 읽어야 합니다.
       * secrets 폴더에 있는 파일명을 key로 생각하면 이해하기 좋습니다.
         secrets 폴더에 있는 파일명의 내용을 value(값)으로 생각하면 좋습니다. 

  실행 방법

   1. 터미널에서 env_example_step3 디렉터리로 이동합니다.
   2. docker compose up --build 명령어를 실행합니다.
   3. http://localhost:8002/db_check에 접속하여 결과를 확인합니다.
   4. 각 컨케이너의 /run/secrets/ 폴더를 확인합니다 
      docker exec env_example_step3-backend-1 ls /run/secrets
      
      * db_password 파일 존재를 확인 합니다 
      
      docker exec env_example_step3-backend-1 cat /run/secrets/db_password
      
      * db_password 파일 내용을 확인 합니다 

      docker exec env_example_step3-db-1 ls /run/secrets
      
      * db_password, db_root_password 두개의 파일 존재를 확인 합니다 
      
      docker exec env_example_step3-db-1 cat /run/secrets/db_password
      docker exec env_example_step3-db-1 cat /run/secrets/db_root_password
      
      * 파일 내용을 확인 합니다 
      
  결론
  
  개발 초기 단계에서는 .env 파일을 사용하여 진행합니다.
  프로덕션 환경으로 전환할 때는 반드시 Docker Secrets를 사용하여 민감한 정보를 안전하게 관리해야 합니다.

 4단계 
  덜 민감한 정보가 여러부분에 사용될 수 있어 .env로 분리하여 유지 보수에 좋게 변경합니다 
  
  프로젝트 구조

  민감한 정보를 담을 secrets 디렉터리를 추가합니다.

   ───env_example_step4/
      ├───.env               #추가됨  
      ├───.gitignore          
      ├───docker-compose.yml #수정됨 
      ├───backend/
      │   ├───main.py        
      │   ├───Dockerfile
      │   └───requirements.txt
      └───secrets/           
          ├───db_password.txt
          └───db_root_password.txt
  
  설명 및 실행방법은 위와 동일합니다 


 5단계
  개발(Development)과 프로덕션(Production) 환경 분리

  실제 프로젝트에서는 개발 환경과 프로덕션 환경의 요구사항이 다릅니다.

   * 개발 환경:
       * 코드 변경 시 즉시 반영되어야 합니다 (Live Reload).
       * 디버깅이 쉬워야 하며, 포트가 로컬 머신에 노출되어야 합니다.
       * 비밀번호 같은 민감 정보가 다소 덜 엄격하게 관리되어도 괜찮습니다 (예: .env 파일).

   * 프로덕션 환경:
       * 보안이 최우선입니다. 민감 정보는 Docker Secrets를 통해 안전하게 관리되어야 합니다.
       * 성능과 안정성이 중요하며, 코드는 이미지 안에 빌드되어 있어야 합니다.
       * 불필요한 포트 노출을 최소화하고, 보통 리버스 프록시 뒤에서 실행됩니다.

  이 두 가지 다른 요구사항을 충족시키기 위해, 여러 개의 `docker-compose` 파일을 목적에 맞게 조합하여 사용하는 전략이 매우
  효과적입니다.

  핵심 전략

   1. `docker-compose.yml` (기본): 모든 환경(개발, 프로덕션 등)에서 공통으로 사용되는 서비스의 기본 정의를 담습니다.
   2. `docker-compose.override.yml` (개발용): 개발 환경에만 필요한 설정을 추가합니다. (예: 포트 매핑, 볼륨 마운트). 이
      파일은 docker compose up 실행 시 자동으로 기본 파일과 병합됩니다.
   3. `docker-compose.prod.yml` (프로덕션용): 프로덕션 환경에만 필요한 설정을 추가합니다. (예: Docker Secrets 사용, 재시작
       정책). 이 파일은 실행 시 명시적으로 지정해 주어야 합니다.

  프로젝트 구조

   ──env_example_step4/
     ├───.env                # 개발용 환경 변수
     ├───.env.prod           # 프로덕션용 환경 변수
     ├───.gitignore          # 
     ├───docker-compose.yml  # 공통 설정
     ├───docker-compose.override.yml # 개발용 오버라이드
     ├───docker-compose.prod.yml     # 프로덕션용 오버라이드
     ├───backend/
     │   ├───main.py
     │   ├───Dockerfile
     │   └───requirements.txt
     ├───nginx/
     │   └───nginx.conf
     └───secrets/
         ├───db_root_password # 프로덕션용 비밀번호
         └───db_password.txt  # 프로덕션용 비밀번호
         

  자세한 설명

   * `docker-compose.yml` (공통 파일):
       * backend와 db 서비스의 가장 기본적인 구조만 정의합니다.
       * build, image, depends_on 처럼 어떤 환경에서든 동일한 내용을 담습니다.
       * environment에는 .env 파일로부터 값을 가져올 변수(APP_MODE, DB_HOST 등)들만 선언해 둡니다.

   * `docker-compose.override.yml` (개발용):
       * docker compose up 시 자동으로 로드됩니다.
       * backend 서비스에 ports를 추가하여 로컬에서 API에 접근할 수 있게 합니다.
       * volumes: - ./backend:/app 설정을 통해 로컬의 backend 폴더를 컨테iner의 /app 폴더에 마운트합니다. 이것이 바로 Live
         Reload의 핵심입니다. 로컬에서 코드를 수정하면 즉시 컨테이너 내부에 반영됩니다.
       * environment에 DB_PASSWORD를 추가하여 .env 파일에서 개발용 비밀번호를 읽어오게 합니다.

   * `docker-compose.prod.yml` (프로덕션용):
       * restart: always 정책을 추가하여 예기치 않게 컨테이너가 종료되었을 때 자동으로 재시작되도록 합니다.
       * backend와 db 서비스 모두에 secrets를 설정하여, ./secrets/ 디렉터리의 파일로부터 민감한 정보를 읽어오도록 합니다.
       * 포트 매핑이 없습니다. 프로덕션에서는 보통 Nginx 같은 리버스 프록시가 앞단에서 요청을 받아 Docker 내부 네트워크를
         통해 backend 서비스와 통신하므로, 외부에 직접 포트를 노출하지 않는 것이 안전합니다.

   * `backend/main.py`:
       * APP_MODE 환경 변수를 읽어 현재 실행 환경이 'development'인지 'production'인지 확인합니다.
       * APP_MODE 값에 따라 분기 처리를 합니다.
           * 프로덕션 모드일 경우: get_secret() 함수를 통해 Docker Secret에서 비밀번호를 읽습니다.
           * 개발 모드일 경우: os.getenv()를 통해 환경 변수에서 비밀번호를 읽습니다.

  실행 방법

  이제 두 가지 환경을 어떻게 실행하는지 보여드리겠습니다.

  1. 개발 환경 실행

  개발 시에는 이 명령 하나면 충분합니다.

   1 # /env_example_advanced 디렉터리에서 실행
   2 docker compose up --build

   * 작동 원리: docker-compose는 자동으로 docker-compose.yml과 docker-compose.override.yml을 순서대로 읽어 설정을 병합합니다. 
     또한, 기본 .env 파일을 읽어 변수를 치환합니다.
     왜 override(덮어쓰다)라는 이름을 사용하는지, 이것은 Docker Compose의 설계 철학과 깊은 관련이 있습니다.
     override를 사용하는 이유: "마법"같은 자동화를 위해 docker-compose.yml을 기본으로하고 추가적인 설정은 
     docker-compose.override.yml파일명으로 해서 Docker Compose가 자동으로 인식하는 특별한 이름이기 때문입니다.
  
   * 결과: localhost:8005으로 API에 접근할 수 있으며, 로컬 main.py 파일을 수정하면 서버가 자동으로 재시작됩니다.
           main.py 파일의 read_root() 함수에서 message의 값을 변경하고 잠시 후 curl localhost:8005로 확인 해봅니다 
           수정 파일을 감지하고 서버가 자동으로 재시작되는 것을 확인 할 수 있습니다 
           
           
  2. 프로덕션 환경 실행

  프로덕션 서버에 배포할 때는 아래와 같이 명시적으로 파일을 지정해야 합니다.

   # /env_example_advanced 디렉터리에서 실행
   docker compose-f docker-compose.yml -f docker-compose.prod.yml --env-file .env.prod up -d --build

   * 작동 원리:
       * -f docker-compose.yml: 기본 설정을 로드합니다.
       * -f docker-compose.prod.yml: 프로덕션용 설정으로 기본 설정을 덮어씁니다. (override.yml은 무시됩니다)
       * --env-file .env.prod: 변수 치환에 .env.prod 파일을 사용하도록 지정합니다.
       * -d: Detached 모드로, 백그라운드에서 컨테이너를 실행합니다.
   * 결과: 코드가 빌드된 이미지를 사용하는 안전하고 안정적인 프로덕션용 컨테이너가 실행됩니다. 모든 민감 정보는 Docker
     Secrets를 통해 안전하게 관리됩니다.
     localhost:8005으로 API에 접근할 수 있으며, 

  이 방법의 장점

   * 명확한 역할 분리: 각 파일이 명확한 목적을 가지므로 설정 관리가 매우 깔끔해집니다.
   * 최고 수준의 보안: 프로덕션 환경의 민감 정보를 개발 환경과 완벽하게 분리하고, Docker Secrets로 안전하게 보호합니다.
   * 개발 생산성 향상: 개발자는 Live Reload와 같은 편의 기능을 사용하고, 배포 스크립트는 프로덕션용 설정을 사용하여 일관된
     배포가 가능합니다.
   * 확장성: staging, testing 등 다른 환경이 필요하다면 docker-compose.staging.yml 같은 파일을 추가하는 것만으로 쉽게
     확장할 수 있습니다.



