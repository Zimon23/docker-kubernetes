  1. 스택(Stack)이란 무엇인가요?

  간단히 말해, 스택은 하나의 애플리케이션을 구성하는 여러 관련 서비스(Service)들의 묶음입니다.

   - 서비스(Service): 애플리케이션을 구성하는 개별 기능 단위입니다. 예를 들어, 웹 서버, 데이터베이스, 캐시
     서버 등이 각각 하나의 서비스가 될 수 있습니다. 이 서비스는 하나 이상의 컨테이너로 실행됩니다.
   - 스택(Stack): 이 서비스들이 모여 하나의 완전한 애플리케이션 스택을 이룹니다. 예를 들어 '웹 프론트엔드',
     '백엔드 API', '데이터베이스' 서비스를 모두 묶어 'my-app-stack'이라는 하나의 단위로 관리할 수 있습니다.

  스택을 사용하면 여러 개의 서비스를 개별적으로 관리하는 대신, 하나의 논리적인 단위로 묶어 애플리케이션
  전체의 배포, 확장, 업데이트, 삭제를 한 번에 관리할 수 있습니다.

  2. Docker Compose와 스택의 관계

  Docker Compose는 본래 단일 호스트에서 여러 컨테이너를 정의하고 실행하기 위한 도구입니다.
  docker-compose.yml 파일에 애플리케이션을 구성하는 서비스, 네트워크, 볼륨 등을 정의하죠.

  스택은 Docker의 클러스터 관리 도구인 Docker Swarm 모드에서 `docker-compose.yml` 파일을 사용하여 여러
  서비스의 묶음을 배포할 때 사용되는 개념입니다.

   - `docker-compose.yml`: 스택의 설계도 또는 정의 파일입니다. 어떤 서비스들이 있고, 각 서비스는 어떤
     이미지를 사용하며, 어떻게 연결되는지 등을 정의합니다.
   - `docker-compose up`: 단일 Docker 호스트(내 PC 등)에서 docker-compose.yml에 정의된 컨테iner를
     실행합니다. 주로 개발 환경에서 사용합니다.
   - `docker stack deploy`: Docker Swarm 클러스터에 docker-compose.yml 파일을 기반으로 스택을 배포합니다.
     여러 서버에 걸쳐 서비스를 분산 실행하고 관리할 수 있게 해줍니다. 주로 운영(Production) 환경에서
     사용합니다.

  즉, `docker-compose.yml` 파일 하나로 개발 환경(Compose)과 운영 환경(Swarm Stack) 모두에서 애플리케이션을
  동일하게 정의하고 관리할 수 있는 것이 핵심입니다.

  3. Docker Stack의 주요 개념

   * Docker Swarm: Docker Stack을 사용하려면 먼저 Docker Swarm 모드가 활성화되어 있어야 합니다. Swarm은 여러
     Docker 엔진을 하나의 가상 Docker 엔진처럼 작동하게 하는 클러스터링 기능입니다.
     
   * 서비스 (Service): Stack의 핵심 구성 요소입니다. docker-compose.yml 파일에 정의되며, 특정 Docker 이미지를
     기반으로 실행될 컨테이너(태스크)의 집합을 나타냅니다. 서비스는 여러 개의 동일한 컨테이너
     인스턴스(레플리카)를 가질 수 있습니다.
     
   * 태스크 (Task): 서비스의 단일 실행 인스턴스입니다. 각 태스크는 하나의 컨테이너를 실행합니다. Swarm은
     서비스의 레플리카 수에 따라 필요한 태스크를 생성하고 관리합니다.
     
   * 노드 (Node): Swarm 클러스터에 참여하는 개별 Docker 엔진 인스턴스입니다.
       * 매니저 노드 (Manager Node): Swarm 클러스터의 관리 및 오케스트레이션 작업을 담당합니다. 서비스 배포,
         스케줄링, 클러스터 상태 유지 등을 수행합니다.
       * 워커 노드 (Worker Node): 애플리케이션 컨테이너(태스크)를 실행하는 역할을 합니다.
       
   * 오버레이 네트워크 (Overlay Network): Stack 내의 서비스들이 서로 다른 노드에 있더라도 투명하게 통신할 수
     있도록 해주는 가상 네트워크입니다. Docker Swarm이 자동으로 생성하고 관리합니다.
     
   * 로드 밸런싱 (Load Balancing): Swarm은 서비스의 모든 태스크에 대한 내장 로드 밸런싱을 제공합니다.
     외부에서 서비스로 들어오는 요청은 자동으로 사용 가능한 태스크 중 하나로 분산됩니다.
     
   * 롤링 업데이트 (Rolling Updates): 서비스 업데이트 시 모든 컨테이너를 한 번에 중지하고 시작하는 대신,
     지정된 지연 시간과 병렬 처리 수에 따라 컨테이너를 순차적으로 업데이트하여 서비스 중단 없이 업데이트를
     수행합니다.
     
   * 스케일링 (Scaling): docker-compose.yml 파일의 replicas 설정을 변경하거나 docker service scale 명령어를
     사용하여 서비스의 컨테이너 수를 쉽게 늘리거나 줄일 수 있습니다.
     
   * 헬스 체크 (Health Checks): 서비스의 각 태스크가 정상적으로 작동하는지 주기적으로 확인하는 기능입니다.
     비정상적인 태스크는 자동으로 교체됩니다.
     
  4. docker-compose up, docker stack deploy 비교 

   * `docker-compose up`: 주로 단일 호스트에서 개발 및 테스트 목적으로 여러 컨테이너를 함께 실행할 때
     사용됩니다. 컨테이너는 단일 Docker 엔진 인스턴스 내에서 실행됩니다.
   * `docker stack deploy`: 프로덕션 환경에서 여러 호스트에 걸쳐 분산된 애플리케이션을 배포하고 관리할 때
     사용됩니다. Docker Swarm 클러스터의 오케스트레이션 기능을 활용합니다.

  5. 예시

  Docker Stack을 사용하여 이미지 실행 및 운영 

  이전 단계에서 최적화한 이미지를 사용하여 rolling-update-nginx 디렉토리의
  애플리케이션을 Docker Stack으로 배포하고 운영하는 방법을 단계별로 알아보겠습니다.
  실제로 rolling-update-nginx 폴더를 stack/step1 폴더로 복사하여 진행합니다 

  1단계: Docker Swarm 초기화 (필수 전제 조건)

  Docker Stack을 사용하려면 Docker Swarm 모드가 활성화되어 있어야 합니다. 현재 시스템이 단일 노드인
  경우에도 Swarm을 초기화하는 것은 3.2 문서를 참조하세요.

  2단계: Docker 이미지 빌드

  Stack에 배포할 애플리케이션 이미지를 빌드해야 합니다. 이전에 최적화한 Dockerfile을 사용하여 이미지를
  빌드합니다.

  `stack/step1` 디렉토리로 이동:

   cd stack/step1
   
   폴더 구조

    stack/step1
    ├── Dockerfile
    ├── docker-compose.yml
    ├── main.py
    ├── nginx
    │   └── nginx.conf
    └── requirements.txt   
   

  이미지 빌드 명령어:
    docker build -t my-fastapi-app:1.0 .

    docker build 와 docker compose build 명령의 차이점 
    
    docker compose build 명령어를 사용할 이미지를 생성 할 수도 있습니다. 하지만 docker build -t my-fastapi-app:1.0 .와
    docker compose build는 목적과 작동 방식에 약간의 차이가 있으며, 특히 Docker Stack 배포 시에는 권장되는
    방식이 다릅니다.

    docker build -t my-fastapi-app:1.0 .

     * 목적: 특정 Dockerfile을 사용하여 이미지를 빌드하고, 지정된 이름(my-fastapi-app)과 태그(1.0)를 부여합니다.
     * 작동 방식: Docker CLI의 기본 이미지 빌드 명령어입니다. 빌드된 이미지는 로컬 Docker 이미지 캐시에 저장됩니다.
     * Docker Stack과의 관계: docker stack deploy 명령은 docker-compose.yml 파일에 명시된 image 이름과 태그를
       사용하여 이미지를 찾습니다. docker build로 명확하게 태그를 지정해두면, docker stack deploy가 로컬
       캐시에서 해당 이미지를 찾거나, 없으면 Docker Hub와 같은 레지스트리에서 해당 태그의 이미지를
       풀(pull)하려고 시도합니다. 이는 특정 버전의 이미지를 배포하는 데 매우 명확하고 제어하기 쉽습니다.

    docker compose build

     * 목적: docker-compose.yml 파일에 정의된 서비스 중 build 컨텍스트가 있는 서비스의 이미지를 빌드합니다.
     * 작동 방식: docker compose CLI의 일부이며, docker-compose.yml 파일의 build 섹션을 읽어 이미지를
       빌드합니다. 이 명령어는 일반적으로 서비스 이름과 프로젝트 이름을 기반으로 이미지를 자동으로 태그합니다
       (예: 프로젝트이름-서비스이름:latest).
     * Docker Stack과의 관계:
         * 자동 태깅 문제: docker compose build는 my-fastapi-app:1.0과 같은 명시적인 태그를 생성하지 않습니다.
           대신 docker-compose 프로젝트 이름과 서비스 이름을 조합한 태그(예: docker-compose_web:latest)를
           사용합니다. 만약 docker-compose.yml 파일에 image: my-fastapi-app:1.0으로 명시되어 있다면, docker
           compose build로 생성된 이미지는 이 태그와 일치하지 않아 docker stack deploy가 해당 이미지를 찾지
           못할 수 있습니다. 이 경우, 빌드된 이미지를 수동으로 다시 태그하거나 docker-compose.yml의 image
           필드를 자동 생성된 태그로 변경해야 합니다.
         * 빌드 컨텍스트 처리: docker stack deploy는 docker-compose.yml 파일에 build 섹션이 포함되어 있을 때,
           해당 이미지를 배포 명령이 실행된 매니저 노드에서 빌드하려고 시도합니다. 이는 몇 가지 문제를 야기할
           수 있습니다:
             * 빌드 컨텍스트(소스 코드 등)가 매니저 노드에 없을 수 있습니다.
             * 매니저 노드에서 이미지를 빌드하는 것은 리소스를 소모하고 배포 프로세스를 지연시킬 수 있습니다.
             * 빌드된 이미지는 기본적으로 매니저 노드에만 존재하며, 다른 워커 노드에서는 사용할 수 없습니다.
               워커 노드에서 이미지를 사용하려면 매니저 노드에서 빌드된 이미지를 Docker Registry(예: Docker Hub
               또는 프라이빗 레지스트리)에 푸시해야 합니다.

    권장 사항

     * `docker compose build`는 주로 로컬 개발 환경에서 `docker compose up`과 함께 사용하기에 적합합니다. 개발
       편의성을 위해 이미지를 자동으로 빌드하고 관리하는 데 유용합니다.
     * `docker stack deploy`를 사용하여 프로덕션 환경에 배포할 때는 `docker build -t <이미지이름>:<태그> .`
       명령어를 사용하여 이미지를 명시적으로 빌드하고 태그를 지정하는 것이 일반적이고 권장되는 방식입니다.
         1. 이미지 빌드: docker build -t my-fastapi-app:1.0 .
         2. 이미지 푸시 (선택 사항이지만 권장): docker push my-fastapi-app:1.0 (Docker Registry에 이미지를
            업로드)
         3. Stack 배포: docker stack deploy -c docker-compose.yml myappstack (Swarm이 레지스트리에서 이미지를
            풀하여 사용)

    이러한 워크플로우는 이미지 버전 관리를 용이하게 하고, CI/CD 파이프라인과 통합하기 쉬우며, Swarm
    클러스터의 모든 노드에서 일관된 이미지를 사용할 수 있도록 보장합니다.
    

  3단계: docker-compose.yml 파일

   build 구문을 삭제해 주세요.
   stack에서는 build 구문을 사용하지 않습니다 

vi docker-compose.yml
#version: '3.8'

services:
  web:
#    build: .  #해당 구문을 삭제합니다 
    image: my-fastapi-app:1.0
    environment:
      - APP_VERSION=v1.0
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/healthz"]
      interval: 10s
      timeout: 5s
      retries: 3
  
  nginx:
    image: nginx:alpine
    ports:
      - "80:80" 
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - web
   
  설명:
   * services: 배포할 서비스들을 정의합니다. 여기서는 web (FastAPI 애플리케이션)과 nginx (리버스 프록시) 두
     가지 서비스가 있습니다.
   * web 서비스의 deploy 섹션은 Swarm 모드에서 이 서비스가 어떻게 배포되고 관리될지를 정의합니다. replicas는
     서비스의 인스턴스 수를, update_config는 롤링 업데이트 방식을, healthcheck는 서비스의 건강 상태를
     모니터링하는 방법을 지정합니다.
   * nginx 서비스는 web 서비스로 요청을 전달하는 리버스 프록시 역할을 합니다. depends_on은 nginx가 web
     서비스가 시작된 후에 시작되어야 함을 나타냅니다.

  4단계: Stack 배포

  이제 docker-compose.yml 파일을 사용하여 Docker Stack을 배포합니다.

  명령어:
     docker stack deploy -c docker-compose.yml myappstack

  설명:
   * docker stack deploy: Docker Swarm에 Stack을 배포하는 명령어입니다.
   * -c docker-compose.yml: 배포에 사용할 Compose 파일(docker-compose.yml)을 지정합니다.
   * myappstack: 배포될 Stack의 이름입니다. 이 이름은 Swarm 내에서 Stack을 식별하는 데 사용됩니다.
   * 실행중 다음과 같은 경고 메시지가 출력됩니다 . 

    Since --detach=false was not specified, tasks will be created in the background.
    In a future release, --detach=false will become the default.

   1. "Since `--detach=false` was not specified, tasks will be created in the background."
       * --detach (또는 -d) 플래그는 Docker 컨테이너나 서비스를 백그라운드에서 실행하도록 지시하는 데
         사용됩니다. 이 플래그를 사용하면 명령을 실행한 후 즉시 터미널 제어권을 돌려받습니다.
       * --detach=false는 "백그라운드에서 실행하지 마라"는 의미입니다. 즉, 명령이 완료될 때까지 터미널에서
         기다리거나, 서비스 생성 진행 상황을 포그라운드에서 보여주라는 뜻입니다.
       * 현재 docker stack deploy와 같은 명령어는 기본적으로 백그라운드(--detach=true와 동일)에서 서비스를
         생성합니다.
       * 이 메시지는 당신이 --detach=false를 명시적으로 지정하지 않았기 때문에, 현재의 기본 동작인
         "백그라운드에서 태스크를 생성"하고 있다는 것을 알려줍니다.

   2. "In a future release, `--detach=false` will become the default."
       * 이것이 핵심입니다. Docker의 미래 버전에서는 docker stack deploy와 같은 명령어의 기본 동작이 변경될
         것이라는 의미입니다.
       * 현재는 명령을 실행하면 즉시 터미널 제어권을 돌려받지만, 미래에는 기본적으로 서비스가 완전히 생성되고
         안정화될 때까지 명령이 터미널에서 기다리게 될 것입니다 (즉, --detach=false가 기본값이 됩니다).
       * 만약 미래에도 현재와 같이 백그라운드에서 실행되기를 원한다면, 그때는 명시적으로 docker stack deploy
         -d 또는 docker stack deploy --detach 플래그를 추가해야 할 것입니다.
   



  이 명령어를 실행하면 Docker Swarm은 docker-compose.yml 파일에 정의된 서비스, 네트워크, 볼륨 등을
  생성하고, 지정된 레플리카 수에 따라 컨테이너를 클러스터 노드에 배포합니다.

  5단계: 배포 확인

  Stack이 성공적으로 배포되었는지 확인합니다.

  5.1 배포된 Stack 목록 확인:
    docker stack ls
    
    실행 결과 
    NAME         SERVICES
    myappstack   2
    
    배포된 모든 Stack의 목록을 보여줍니다. myappstack이 목록에 나타나야 합니다.

  5.2 Stack 내 서비스 목록 확인:
    docker stack services myappstack

    실행 결과 
    ID             NAME               MODE         REPLICAS   IMAGE                PORTS
    w6o4pdwyclc6   myappstack_nginx   replicated   1/1        nginx:alpine         *:80->80/tcp
    27f5bh0hev9r   myappstack_web     replicated   3/3        my-fastapi-app:1.0
  
    myappstack 내에 배포된 서비스(web, nginx)와 각 서비스의 레플리카 수, 상태 등을 보여줍니다.

  5.3 특정 서비스의 태스크(컨테이너) 상태 확인:
     docker service ps myappstack_web
     
실행 결과 
ID             NAME                   IMAGE                NODE      DESIRED STATE   CURRENT STATE                     ERROR                              PORTS
z4zspada7cka   myappstack_web.1       my-fastapi-app:1.0   node1     Ready           Preparing 1 second ago           
8dyyydyib3h0    \_ myappstack_web.1   my-fastapi-app:1.0   node2     Shutdown        Rejected 2 seconds ago            "No such image: my-fastapi-app…"
iuyy0qoedhct    \_ myappstack_web.1   my-fastapi-app:1.0   node2     Shutdown        Rejected 6 seconds ago            "No such image: my-fastapi-app…"
mhn39cf5rsko   myappstack_web.2       my-fastapi-app:1.0   node2     Ready           Preparing 1 second ago           
rua3rcgsu6zw    \_ myappstack_web.2   my-fastapi-app:1.0   node1     Shutdown        Rejected 2 seconds ago            "No such image: my-fastapi-app…"
plujw1omd26t    \_ myappstack_web.2   my-fastapi-app:1.0   node1     Shutdown        Rejected 6 seconds ago            "No such image: my-fastapi-app…"
9u2y8vd299fq   myappstack_web.3       my-fastapi-app:1.0   manager   Running         Starting less than a second ago  
0unhv1ediqj1    \_ myappstack_web.3   my-fastapi-app:1.0   manager   Shutdown        Failed 5 seconds ago   
     
     docker service ps myappstack_nginx

실행 결과 
ID             NAME                     IMAGE          NODE      DESIRED STATE   CURRENT STATE                     ERROR                              PORTS
vaeblkyhjy78   myappstack_nginx.1       nginx:latest   node1     Ready           Rejected less than a second ago   "invalid mount config for type…"
oe2m6vjvw0xj    \_ myappstack_nginx.1   nginx:latest   node2     Shutdown        Rejected 5 seconds ago            "invalid mount config for type…"
io9kjw64frgr    \_ myappstack_nginx.1   nginx:latest   node2     Shutdown        Rejected 10 seconds ago           "invalid mount config for type…"
pvnd2nxzma2z    \_ myappstack_nginx.1   nginx:latest   node2     Shutdown        Rejected 15 seconds ago           "invalid mount config for type…"
5et9i1tjwhde    \_ myappstack_nginx.1   nginx:latest   node2     Shutdown        Rejected 20 seconds ago           "invalid mount config for type…"

  
  설명: myappstack_web 서비스의 각 태스크(컨테이너)가 어떤 노드에서 실행 중인지, 상태는 어떤지 등을 상세히
  보여줍니다. myappstack_nginx도 마찬가지입니다.

  5.4 서비스 로그 확인:
     docker service logs myappstack_web

실행 결과 
myappstack_web.2.ol4k6f1m0olb@manager    | INFO:     Started server process [1]
myappstack_web.2.ol4k6f1m0olb@manager    | INFO:     Waiting for application startup.
myappstack_web.2.ol4k6f1m0olb@manager    | INFO:     Application startup complete.
myappstack_web.2.ol4k6f1m0olb@manager    | INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
myappstack_web.2.ol4k6f1m0olb@manager    | INFO:     127.0.0.1:47858 - "GET /healthz HTTP/1.1" 200 OK
myappstack_web.3.x5khz9xoljpo@manager    | INFO:     Started server process [1]
myappstack_web.3.x5khz9xoljpo@manager    | INFO:     Waiting for application startup.
myappstack_web.3.x5khz9xoljpo@manager    | INFO:     Application startup complete.
myappstack_web.3.x5khz9xoljpo@manager    | INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
myappstack_web.3.x5khz9xoljpo@manager    | INFO:     127.0.0.1:47866 - "GET /healthz HTTP/1.1" 200 OK
myappstack_web.1.pc2b0vng198d@manager    | INFO:     Started server process [1]
myappstack_web.1.pc2b0vng198d@manager    | INFO:     Waiting for application startup.
myappstack_web.1.pc2b0vng198d@manager    | INFO:     Application startup complete.
myappstack_web.1.pc2b0vng198d@manager    | INFO:     Uvicorn running on http://0.0.0.0:8000 (Press CTRL+C to quit)
myappstack_web.1.pc2b0vng198d@manager    | INFO:     127.0.0.1:58898 - "GET /healthz HTTP/1.1" 200 OK
myappstack_web.1.pc2b0vng198d@manager    | INFO:     127.0.0.1:35990 - "GET /healthz HTTP/1.1" 200 OK
myappstack_web.1.pc2b0vng198d@manager    | INFO:     127.0.0.1:47844 - "GET /healthz HTTP/1.1" 200 OK
myappstack_web.1.pc2b0vng198d@manager    | INFO:     127.0.0.1:40286 - "GET /healthz HTTP/1.1" 200 OK     
     
     
     docker service logs myappstack_nginx
  
실행 결과 
myappstack_nginx.1.j521rim3vnax@manager    | /docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration
myappstack_nginx.1.j521rim3vnax@manager    | /docker-entrypoint.sh: Looking for shell scripts in /docker-entrypoint.d/
myappstack_nginx.1.j521rim3vnax@manager    | /docker-entrypoint.sh: Launching /docker-entrypoint.d/10-listen-on-ipv6-by-default.sh
myappstack_nginx.1.j521rim3vnax@manager    | 10-listen-on-ipv6-by-default.sh: info: Getting the checksum of /etc/nginx/conf.d/default.conf
myappstack_nginx.1.j521rim3vnax@manager    | 10-listen-on-ipv6-by-default.sh: info: /etc/nginx/conf.d/default.conf differs from the packaged version
myappstack_nginx.1.j521rim3vnax@manager    | /docker-entrypoint.sh: Sourcing /docker-entrypoint.d/15-local-resolvers.envsh
myappstack_nginx.1.j521rim3vnax@manager    | /docker-entrypoint.sh: Launching /docker-entrypoint.d/20-envsubst-on-templates.sh
myappstack_nginx.1.j521rim3vnax@manager    | /docker-entrypoint.sh: Launching /docker-entrypoint.d/30-tune-worker-processes.sh
myappstack_nginx.1.j521rim3vnax@manager    | /docker-entrypoint.sh: Configuration complete; ready for start up
myappstack_nginx.1.j521rim3vnax@manager    | 2025/08/15 10:24:56 [notice] 1#1: using the "epoll" event method
myappstack_nginx.1.j521rim3vnax@manager    | 2025/08/15 10:24:56 [notice] 1#1: nginx/1.29.1
myappstack_nginx.1.j521rim3vnax@manager    | 2025/08/15 10:24:56 [notice] 1#1: built by gcc 12.2.0 (Debian 12.2.0-14+deb12u1)
myappstack_nginx.1.j521rim3vnax@manager    | 2025/08/15 10:24:56 [notice] 1#1: OS: Linux 5.15.0-151-generic
myappstack_nginx.1.j521rim3vnax@manager    | 2025/08/15 10:24:56 [notice] 1#1: getrlimit(RLIMIT_NOFILE): 1048576:1048576
myappstack_nginx.1.j521rim3vnax@manager    | 2025/08/15 10:24:56 [notice] 1#1: start worker processes
myappstack_nginx.1.j521rim3vnax@manager    | 2025/08/15 10:24:56 [notice] 1#1: start worker process 28
myappstack_nginx.1.j521rim3vnax@manager    | 2025/08/15 10:24:56 [notice] 1#1: start worker process 29
  
  
  설명: 각 서비스의 컨테이너에서 발생하는 로그를 실시간으로 확인하여 애플리케이션이 정상적으로 작동하는지
  모니터링할 수 있습니다.


  중요 : 실제 문제 발생 
  step1   nginx.conf 파일 volume 문제 발생 
          실행시 docker-compose.yml 파일이 위한 폴더에 nginx/nginx.conf 파일이 존재 합니다 
          해당 파일은 manager 서버에 존재하고 node1, node2에 존재하지 않습니다 
          그래서 node1, node2에서 nginx를 실행 하려고 하지만 실패를 하게 됩니다 
          volume은 단일 호스트에서 사용할 때문 문제가 없지만 다중 서버를 사용할 때는 문제가 발생합니다 
          
          manager (정상 실행됨 )
          docker ps -a 
          
          node1 (컨테이너 실행 안됨)
          docker ps -a 
          
          node2 (컨테이너 실행 안됨)
          docker ps -a 
          
          
  step2 stack config nginx volume 문제 발생 해결 방법 
  
  폴더 구조 
    stack/step2
    ├── Dockerfile
    ├── docker-compose.yml    #수정됩니다
    ├── main.py
    ├── nginx
    │   └── nginx.conf
    ├── requirements.txt
    └── setup-configs.sh      #추가된 파일 
  
       swarm config를 사용하여 해결해야 합니다
       manager 에서 명령으로 config 개체를 생성합니다 (아래 좀더 편하게 작업하는 방법 설명)
       
       docker config create nginx_config ./nginx/nginx.conf
       
       nginx_config 이름으로 ./nginx/nginx.conf 파일을 관리 할 수 있게 객체를 생성하는 것입니다 
       
       위 작업을 다음에도 사용할 수 있게 shell 파일로 생성하서 관리 합니다 
       vi setup-config.sh 
       #/bin/bash 
       docker config create nginx_config ./nginx/nginx.conf
       
       chmod +x setup-config.sh 
       
       ./setup-config.sh  명령으로 실행하시면 됩니다 
       
vi docker-compose.yml 
#version: '3.8'

services:
  web:
    image: my-fastapi-app:1.0
    environment:
      - APP_VERSION=v1.0
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/healthz"]
      interval: 10s
      timeout: 5s
      retries: 3
  
  nginx:
    image: nginx:latest
    ports:
      - "80:80" 
    configs:                        #config로 변경해야 됨 
      - source: nginx_config
        target: /etc/nginx/conf.d/default.conf
    depends_on:
      - web

configs:   #config로 변경해야 됨 
  nginx_config:
    external: true       
       
---------------------------------------------------------------------------       
       
       다음과 같이 실행하시고 로그를 확인해보시면 약간 문제가 있는 것을 확인 할 수 있습니다 
       docker stack deploy -c docker-compose.yml myappstack
       docker stack ps myappstack
       
       manager, node1, node2로 균등하게 실행되는 것이 아니라 manager에서만 실행되는 것을 확인 할 수 있습니다 
       이유는 manager에서만 my-fastapi-app 이미지가 존재하고 다른 node에서는 이미지가 존재하지 않기 때문입니다 
       이를 해결 하려면 docker hub 또는 사설 저장소에 이미지가 저장되어야 합니다 
       
  step3   my-fastapi-app 이미지를 docker hub에 push 하고 docker hub에서 내려 받게 기능 수정 

  폴더 구조 
    stack/step3
    ├── Dockerfile
    ├── build.sh             #이미지 빌드를 위한 파일 생성 
    ├── docker-compose.yml   #이지미 docker hub에서 내려받는 것으로 수정함 
    ├── main.py
    ├── nginx
    │   └── nginx.conf
    ├── requirements.txt
    └── setup-configs.sh


vi build.sh
docker build -t masungil/my-fastapi-app:1.0 . --no-cache
echo "이미지 빌드 성공"

docker login -u masungil -p$DOCKER_PASSWORD
echo "로그인 성공"

docker push masungil/my-fastapi-app:1.0
echo "이미지 푸시 성공"
      
chmod +x build.sh

vi docker-compose.yml 
#version: '3.8'

services:
  web:
    image: masungil/my-fastapi-app:1.0    #docker hub에서 이미지 내려 받게 수정합니다 
    environment:
      - APP_VERSION=v1.0
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/healthz"]
      interval: 10s
      timeout: 5s
      retries: 3
  
  nginx:
    image: nginx:latest
    ports:
      - "80:80" 
    configs:
      - source: nginx_config
        target: /etc/nginx/conf.d/default.conf
    depends_on:
      - web

configs:
  nginx_config:
    external: true
-------------------------------------------------------------------------  
   
   다음과 같이 실행하시고 로그를 확인해 보시면 정상적으로 각 노드에서 실행되는 것을 확인 할 수 있습니다  
       docker stack deploy -c docker-compose.yml myappstack
       docker stack ps myappstack

  6단계: Stack 운영 및 관리

  Stack이 배포된 후에는 다양한 운영 및 관리 작업을 수행할 수 있습니다.

  서비스 스케일링 (Scaling)

  서비스의 컨테이너 수를 동적으로 변경할 수 있습니다.

  6.1: `docker service scale` 명령어 사용 (임시 변경)
     
     docker service scale myappstack_web=5
  
     실행결과 
myappstack_web scaled to 5
overall progress: 5 out of 5 tasks
1/5: running
2/5: running
3/5: running
4/5: running
5/5: running
verify: Service myappstack_web converged

     
     myappstack_web 서비스의 레플리카 수를 5개로 즉시 변경합니다. 이는 docker-compose.yml 파일의 설정을
  덮어쓰는 임시 변경입니다.



  방법 2: `docker-compose.yml` 파일 수정 후 재배포 (영구 변경)
  docker-compose.yml 파일에서 web 서비스의 replicas 값을 3에서 5로 변경한 후, 다음 명령어를 다시 실행합니다.
      
      docker stack deploy -c docker-compose.yml myappstack
      
  이 방법은 docker-compose.yml 파일에 변경 사항을 영구적으로 반영하고, Stack을 업데이트하여 변경된
  레플리카 수에 맞춰 컨테이너를 조정합니다.

  7단계 : 롤링 업데이트 (Rolling Updates)     

  애플리케이션의 새 버전을 배포할 때 서비스 중단 없이 업데이트를 수행합니다.

  폴더 구조 
stack/step4
├── Dockerfile
├── build-2.0.sh                           #버전2.0 이미지로 빌드하는 스크립트 파일 생성 
├── build.sh
├── docker-compose-rolling-update.yml      #버전2.0 이미지로 롤링 업데이트 파일 생성 
├── docker-compose.yml
├── main.py
├── nginx
│   └── nginx.conf
├── requirements.txt
├── run-test.sh                            #버전 업데이트 되는 과정을 테스트하기 위한 스크립트 파일 생성 
├── setup-configs.sh
├── stack-rm.sh                            #stack 제거하는 스크립트 파일 생성 
├── stack-run-2.0.sh                       #2.0 버전으로 업데이트 하는 stack 배포하는 스크립트 파일 생성   
└── stack-run.sh                           #stack 배포하는 스크립트 파일 생성 
  

7.1 버전 업데이트 되는 과정을 테스트하기 위한 스크립트 파일 생성 
  1초에 1회씩 curl localhost 를 호출한다 
  전체 회수는 1000회 반복하면서 진행을 합니다 
  서버의 결과를 화면에 출력합니다 현재 버전이 무엇인지 확인을 합니다 
  
vi run-test.sh 
#!/bin/bash
# 서버 URL 테스트 실행
for i in {1..1000}
do
  printf "Test $i 시작\n"
  curl localhost
  printf "\nTest $i 종료\n"
  sleep 1
done

--------------------------------------------------------

7.2 stack 배포 실행하는 스크립트 파일 생성 
vi stack-run.sh
#!/bin/bash
# 스택 배포
docker stack deploy -c docker-compose.yml myappstack

--------------------------------------------------------

7.3 stack 제거하는 스크립트 파일 생성 
vi stack-rm.sh
#!/bin/bash
# 스택 배포
docker stack rm myappstack

--------------------------------------------------------

7.4 버전2.0 이미지로 빌드하는 스크립트 파일 생성 
vi build-2.0.sh
#!/bin/bash

#이미지 2.0 빌드하여 docker hub에 push 한다

docker build -t masungil/my-fastapi-app:2.0 . --no-cache
echo "이미지 빌드 성공"

docker login -u masungil -p$DOCKER_PASSWORD
echo "로그인 성공"

docker push masungil/my-fastapi-app:2.0
echo "이미지 푸시 성공"



--------------------------------------------------------


7.5 버전2.0 이미지로 롤링 업데이트 파일 생성 
vi docker-compose-rolling-update.yml
#version: '3.8'

services:
  web:
#    build: .
    image: masungil/my-fastapi-app:2.0   #버전 수정됨 
    environment:
      - APP_VERSION=v2.0                 #버전 수정됨 
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/healthz"]
      interval: 10s
      timeout: 5s
      retries: 3
  
  nginx:
    image: nginx:latest
    ports:
      - "80:80" 
    configs:
      - source: nginx_config
        target: /etc/nginx/conf.d/default.conf
    depends_on:
      - web

configs:
  nginx_config:
    external: true

--------------------------------------------------------

7.6 2.0 버전으로 업데이트 하는 stack 배포하는 스크립트 파일 생성
vi stack-run-2.0.sh
#!/bin/bash
# 스택 배포
docker stack deploy -c docker-compose-rolling-update.yml myappstack


--------------------------------------------------------

7.7 테스트 절차
chmod +x *.sh 

#stack 배포 실행하는 스크립트 파일을 실행 합니다 
./run.sh 

#서버 URL 테스트 실행
./run-test.sh 

#다른 터미널을 실행하고 버전2.0 이미지로 빌드하는 스크립트 파일 실행 합니다 
./build-2.0.sh 

#2.0 버전으로 업데이트 하는 stack 배포하는 스크립트 파일 실행 합니다 
./stack-run-2.0.sh

#서버 URL 테스트 실행 화면을 계속 기다리면서 확인을 하면 버전이 변경되는 것을 확인 할 수 있습니다 
...
실행 화면 
Test 82 시작
{"message":"Hello from version: v1.0","container_id":"778d097e00a7","hostname":"778d097e00a7"}
Test 82 종료
Test 83 시작
{"message":"Hello from version: v2.0","container_id":"e22a6c055e8e","hostname":"e22a6c055e8e"}
Test 83 종료
Test 84 시작
{"message":"Hello from version: v2.0","container_id":"d2dcce3ee8ba","hostname":"d2dcce3ee8ba"}
Test 84 종료
...

--------------------------------------------------------


  헬스 체크 (Health Checks) & rollback 


  docker-compose.yml 파일의 healthcheck 섹션은 서비스 태스크의 건강 상태를 모니터링하는 데 사용됩니다.
  Swarm은 헬스 체크가 실패한 태스크를 자동으로 교체하여 서비스의 안정성을 유지합니다.

  애플리케이션의 새 버전을 배포할 때 서비스 중단 없이 업데이트를 수행합니다.

  폴더 구조 
    stack/step5
    ├── Dockerfile
    ├── Dockerfile-unhealthy                   #헬스 체크 실패 이미지 생성 파일 추가 
    ├── build-2.0.sh                           #헬스 체크 실패 이미지 빌드 수정 파일 
    ├── build.sh
    ├── docker-compose-unhealthy-rollback.yml  #헬스 체크 실패시 롤백 설정 파일 추가 
    ├── docker-compose.yml                  
    ├── main-unhealthy.py                      #헬스 체크 실패 기능 추가된 파일 
    ├── main.py
    ├── nginx
    │   └── nginx.conf
    ├── requirements.txt
    ├── run-test.sh
    ├── setup-configs.sh
    ├── stack-rm.sh
    ├── stack-run-2.0.sh                       #2.0 버전으로 업데이트 시 헬스 체크 실패 stack 배포하는 스크립트 파일 수정
    └── stack-run.sh  
    
  healthcheck 속성 
   * test: 헬스 체크를 수행할 명령어입니다.
   * interval: 헬스 체크를 수행하는 주기입니다.
   * timeout: 헬스 체크 명령어가 완료될 때까지 기다리는 시간입니다.
   * retries: 헬스 체크가 실패했을 때 재시도하는 횟수입니다.

  update_config 속성

  update_config는 서비스의 새로운 버전이 배포될 때(예: 이미지 태그 변경 후 docker stack deploy 실행 시)
  Docker Swarm이 어떻게 업데이트를 수행할지 제어합니다.

   * `parallelism`:
       * 의미: 한 번에 업데이트할 서비스 태스크(컨테이너)의 수입니다.
       * 값: 양의 정수.
           * 1: 한 번에 하나의 컨테이너만 업데이트합니다. 가장 안전하지만 가장 느립니다.
           * N (>1): N개의 컨테이너를 동시에 업데이트합니다. 업데이트 속도는 빠르지만, 문제가 발생했을 때
             영향을 받는 컨테이너 수가 많아집니다.
           * 0: 모든 컨테이너를 동시에 업데이트합니다. 서비스 중단이 발생할 수 있으므로 프로덕션 환경에서는
             권장되지 않습니다.
       * 예시: parallelism: 1은 한 번에 하나의 컨테이너만 업데이트하므로, 업데이트 중 문제가 발생해도 서비스
         전체에 미치는 영향을 최소화합니다.

   * `delay`:
       * 의미: 한 번에 업데이트되는 태스크 그룹(parallelism으로 정의된 수)이 완료된 후 다음 그룹의
         업데이트를 시작하기 전까지 기다릴 시간입니다.
       * 값: 시간 단위 (예: 10s (10초), 1m (1분), 1h (1시간)).
       * 예시: delay: 10s는 한 컨테이너(parallelism: 1인 경우)가 업데이트되고 헬스 체크를 통과한 후 10초를
         기다렸다가 다음 컨테이너 업데이트를 시작합니다. 이는 새로운 버전의 컨테이너가 안정화될 시간을
         제공합니다.

   * `order`:
       * 의미: 업데이트 시 이전 버전의 태스크를 중지하고 새 버전의 태스크를 시작하는 순서입니다.
       * 값:
           * stop-first (기본값): 이전 버전의 태스크를 먼저 중지한 다음, 새 버전의 태스크를 시작합니다. 이
             방식은 일시적인 서비스 중단을 유발할 수 있습니다.
           * start-first: 새 버전의 태스크를 먼저 시작하고, 새 태스크가 정상 상태가 되면 이전 버전의
             태스크를 중지합니다.
       * 예시: order: start-first는 새 컨테이너를 먼저 시작하여 서비스 중단 없이 업데이트를 수행하는 데
         사용됩니다. 하지만 업데이트 중 일시적으로 더 많은 리소스(CPU, 메모리)를 필요로 합니다.

   * `failure_action`:
       * 의미: 업데이트 중 태스크가 실패(예: 헬스 체크 실패)했을 때 Docker Swarm이 취할 조치입니다.
       * 값:
           * continue: 실패한 태스크를 무시하고 업데이트를 계속 진행합니다. (권장되지 않음)
           * pause: 업데이트를 일시 중지합니다. 관리자가 수동으로 개입하여 문제를 해결해야 합니다.
           * rollback: 업데이트를 이전 버전으로 롤백합니다.
       * 예시: failure_action: rollback은 새로운 버전의 컨테이너가 헬스 체크에 실패하면 자동으로 업데이트를
         중단하고 이전 버전으로 되돌립니다. 이는 잘못된 배포로부터 자동으로 복구하는 데 매우 중요합니다.

   * `monitor` (선택 사항):
       * 의미: 업데이트된 태스크가 시작된 후 얼마나 오랫동안 건강 상태를 모니터링할지 지정합니다. 이 기간
         동안 태스크가 비정상 상태가 되면 failure_action이 트리거됩니다.
       * 값: 시간 단위 (예: 5m).

   * `max_failure_ratio` (선택 사항):
       * 의미: failure_action이 트리거되기 전에 허용되는 최대 실패 태스크 비율입니다.
       * 값: 0.0에서 1.0 사이의 부동 소수점 숫자 (예: 0.1은 10% 실패 허용).

  rollback_config 속성

  rollback_config는 update_config의 failure_action: rollback이 트리거되었을 때, Docker Swarm이 서비스를
  이전 버전으로 되돌리는 방법을 제어합니다.

   * `parallelism`:
       * 의미: 롤백 시 한 번에 되돌릴 서비스 태스크(컨테이너)의 수입니다.
       * 값: 양의 정수.
       * 예시: parallelism: 1은 롤백 시에도 한 번에 하나의 컨테이너만 되돌립니다.

   * `delay`:
       * 의미: 롤백 시 한 번에 되돌려지는 태스크 그룹이 완료된 후 다음 그룹의 롤백을 시작하기 전까지 기다릴
         시간입니다.
       * 값: 시간 단위.
       * 예시: delay: 5s는 롤백 시 각 컨테이너 그룹 사이에 5초 지연을 둡니다.

   * `order`:
       * 의미: 롤백 시 새 버전(실패한 버전)의 태스크를 중지하고 이전 버전(정상 작동했던 버전)의 태스크를
         시작하는 순서입니다.
       * 값:
           * stop-first (기본값): 실패한 새 버전의 태스크를 먼저 중지한 다음, 이전 버전의 태스크를
             시작합니다. 롤백 시 빠르게 이전 상태로 복구하는 데 선호됩니다.
           * start-first: 이전 버전의 태스크를 먼저 시작하고, 정상 상태가 되면 실패한 새 버전의 태스크를
             중지합니다.
  
8.1 헬스 체크 버전2.0 이미지로 빌드하는 스크립트 파일 생성 
vi build-2.0.sh
#!/bin/bash

#이미지 2.0 빌드하여 docker hub에 push 한다
#헬스 체크를 위한 Dockerfile-unhealthy를 사용 할 수 있게 수정함   
docker build -f Dockerfile-unhealthy -t masungil/my-fastapi-app:2.0 . --no-cache  #수정됨 
echo "이미지 빌드 성공"

docker login -u masungil -p$DOCKER_PASSWORD
echo "로그인 성공"

docker push masungil/my-fastapi-app:2.0
echo "이미지 푸시 성공"

--------------------------------------------------------

8.2 헬스 체크 버전2.0 이미지로 롤링 업데이트 파일 생성 
vi docker-compose-unhealthy-rollback.yml
#version: '3.8'

services:
  web:
#    build: .
    image: masungil/my-fastapi-app:2.0   #버전 수정됨 
    environment:
      - APP_VERSION=v2.0                 #버전 수정됨 
    deploy:
      replicas: 3
      update_config:
        parallelism: 1
        delay: 10s
        order: start-first
        failure_action: rollback  # <--- 헬스체크 실패 시 롤백하도록 설정
      rollback_config:
        parallelism: 1
        delay: 5s
        order: stop-first   
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/healthz"]
      interval: 10s
      timeout: 5s
      retries: 3
  
  nginx:
    image: nginx:latest
    ports:
      - "80:80" 
    configs:
      - source: nginx_config
        target: /etc/nginx/conf.d/default.conf
    depends_on:
      - web

configs:
  nginx_config:
    external: true

--------------------------------------------------------

8.3 헬스 체크 버전2.0으로 업데이트 하는 stack 배포하는 스크립트 파일 생성
vi stack-run-2.0.sh
#!/bin/bash
# 스택 배포
docker stack deploy -c docker-compose-unhealthy-rollback.yml myappstack

--------------------------------------------------------

8.4 테스트 절차
chmod +x *.sh 

#1.0 버전 이미지 생성 빌드 실행 합니다 
./build.sh 

#stack 배포 실행하는 스크립트 파일을 실행 합니다 
./run.sh 

#서버 URL 테스트 실행
./run-test.sh 

#다른 터미널을 실행하고 버전2.0 이미지로 빌드하는 스크립트 파일 실행 합니다 
./build-2.0.sh 

#2.0 버전으로 업데이트 하는 stack 배포하는 스크립트 파일 실행 합니다 
./stack-run-2.0.sh

#서버 URL 테스트 실행 화면을 계속 기다리면서 확인을 합니다  
...
실행 화면 
Test 779 시작
{"message":"Hello from version: v1.0","container_id":"0c7b20cf804d","hostname":"0c7b20cf804d"}
Test 779 종료
Test 780 시작
{"message":"Hello from version: v1.0","container_id":"30a6ed986738","hostname":"30a6ed986738"}
Test 780 종료
Test 781 시작
{"message":"Hello from version: v1.0","container_id":"789f64f43cf0","hostname":"789f64f43cf0"}
Test 781 종료
...

스택 myappstack의 상태를 확인합니다 
docker stack ps myappstack

실행결과
ID             NAME                     IMAGE                         NODE      DESIRED STATE   CURRENT STATE                 ERROR                       PORTS
8f3jv4nac8cq   myappstack_nginx.1       nginx:latest                  node2     Running         Running 4 minutes ago
m7khbn2wqo32    \_ myappstack_nginx.1   nginx:latest                  node1     Shutdown        Failed 4 minutes ago          "task: non-zero exit (1)"
dc7uvp2fytgs   myappstack_web.1         masungil/my-fastapi-app:1.0   node1     Running         Running about a minute ago
8rofmaezz9s3    \_ myappstack_web.1     masungil/my-fastapi-app:2.0   node1     Shutdown        Shutdown about a minute ago
y04ygzre09ph    \_ myappstack_web.1     masungil/my-fastapi-app:2.0   node1     Shutdown        Complete about a minute ago
3l5m5oseqda0    \_ myappstack_web.1     masungil/my-fastapi-app:1.0   node1     Shutdown        Shutdown about a minute ago
jiq3vrf5rnz8   myappstack_web.2         masungil/my-fastapi-app:1.0   node2     Running         Running 4 minutes ago
63y0t9p46snf   myappstack_web.3         masungil/my-fastapi-app:1.0   manager   Running         Running 4 minutes ago

헬스체크 이미지가 실행을 하고 문제가 있기 때문에 Shutdown된 것을 확인 할 수 있습니다 

--------------------------------------------------------


  Stack 제거

  배포된 Stack을 제거하려면 다음 명령어를 사용합니다.

  명령어:
    docker stack rm myappstack
  설명: 이 명령어를 실행하면 myappstack에 속한 모든 서비스, 태스크, 오버레이 네트워크 등이 제거됩니다.

