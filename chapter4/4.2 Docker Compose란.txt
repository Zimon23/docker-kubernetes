1. Docker Compose란?

  Docker Compose는 여러 개의 컨테이너로 구성된 애플리케이션을 정의하고 실행하기
  위한 도구입니다.

  YAML (.yml) 형식의 설정 파일 하나로 애플리케이션을 구성하는 모든
  서비스(컨테이너), 네트워크, 볼륨 등을 정의할 수 있습니다. 이를 통해 단일
  명령어로 전체 애플리케이션 스택을 시작하거나 중지할 수 있어, 개발 환경 설정과
  배포 과정을 매우 단순화하고 효율적으로 만들어 줍니다.

  핵심 개념:

   * 서비스 (Services): 애플리케이션을 구성하는 개별 컨테이너를 의미합니다.
     예를 들어, 웹 서버, 데이터베이스, 캐시 서버 등이 각각 하나의 서비스가 될
     수 있습니다. 각 서비스는 특정 Docker 이미지를 기반으로 실행되며, 포트,
     볼륨, 네트워크 등 다양한 설정을 가질 수 있습니다.
   * 네트워크 (Networks): Docker Compose는 기본적으로 모든 서비스를 동일한
     네트워크에 연결합니다. 이 덕분에 서비스들은 컨테이너 IP를 직접 알 필요 없이
      서비스 이름을 호스트명처럼 사용하여 서로 통신할 수 있습니다. 
      (예: web 서비스에서 db라는 호스트명으로 데이터베이스에 접속)
   * 볼륨 (Volumes): 컨테이너의 데이터를 영속적으로 저장하기 위해 사용됩니다.
     컨테이너가 중지되거나 삭제되어도 데이터가 보존되어야 하는 데이터베이스
     등에 필수적입니다.

  왜 사용하나요?

   * 환경 설정의 단순화: docker compose up -d.yml 파일 하나만 있으면, docker compose up -d
     up 명령어 한 번으로 복잡한 애플리케이션 환경을 누구나 동일하게 구축할 수
     있습니다.
   * 개발 효율성 증대: 로컬 개발 환경에서 실제 운영 환경과 유사한 다중 컨테이너
     환경을 쉽게 구성하고 테스트할 수 있습니다.
   * 일관성 있는 환경 제공: 개발, 테스트, 운영 환경에서 모두 동일한 설정 파일을
     사용하여 환경 불일치로 인한 문제를 줄일 수 있습니다.
   * 손쉬운 관리: up, down, logs, ps 등 간단한 명령어로 전체 애플리케이션
     스택을 손쉽게 관리할 수 있습니다.

2. Docker Compose를 활용한 웹 서버와 데이터베이스 연동 비교 예제 

  Docker를 사용하여 Apache 웹 서버와 MySQL 데이터베이스 컨테이너를 연동하는 두 가지 방법을 비교하고 설명합니다.

   1. 수동 방식: docker run 명령어를 사용하여 각 컨테이너를 개별적으로 실행하고 연결합니다.
   2. 자동화 방식: docker compose up -d.yml 파일을 사용하여 여러 컨테이너를 한번에 정의하고 관리합니다.

  1. 수동으로 컨테이너 실행 및 연결 (The Manual Way)

  이 방법은 Docker의 기본적인 작동 방식을 이해하는 데 도움이 되지만, 여러개의 컨테이너를 관리하기에는 번거롭습니다.

  1.1. 컨테이너 실행

  1. MySQL 컨테이너 실행

  먼저, mysql 이미지를 사용하여 데이터베이스 컨테이너를 실행합니다.

   # -dit: 백그라운드에서 터미널 입력을 유지한 채로 실행
   # --name mysql: 컨테이너 이름을 'mysql'로 지정
   # -e MYSQL_ROOT_PASSWORD=1004: 환경 변수를 사용하여 root 비밀번호 설정
   docker run -dit --name mysql -e MYSQL_ROOT_PASSWORD=1004 mysql

  2. Apache (httpd) 컨테이너 실행 및 MySQL 연결

  다음으로, httpd 이미지를 사용하여 웹 서버 컨테이너를 실행하고, 앞서 생성한 mysql 컨테이너에 연결합니다.

   # -p 80:80: 호스트의 80번 포트를 컨테이너의 80번 포트로 연결
   # --link mysql:db: 'mysql' 컨테이너를 'db'라는 별칭(alias)으로 연결
   # --name web: 컨테이너 이름을 'web'으로 지정
   docker run -dit -p 80:80 --link mysql:db --name web httpd

  1.2. 컨테이너 관리

  1. 실행 중인 컨테이너 확인

  docker ps -a 명령어로 현재 실행 중이거나 정지된 모든 컨테이너의 목록을 확인할 수 있습니다.

   docker ps -a

  2. 컨테이너 정지 및 제거

  더 이상 사용하지 않는 컨테이너는 stop 명령으로 중지하고 rm 명령으로 제거합니다.

   # 컨테이너 중지
   docker stop mysql
   docker stop web
   
   # 컨테이너 제거
   docker rm mysql
   docker rm web 

  2. Docker Compose를 사용한 자동화 (The Automated Way)

  Docker Compose는 여러 컨테이너로 구성된 애플리케이션을 YAML 파일 하나로 정의하고, 
  단일 명령어로 전체 스택을 관리할 수 있게 해주는 강력한 도구입니다.

  2.1. 기본 사용법 (docker compose up -d.yml)

  1. 작업 폴더 생성 및 이동

  먼저, 프로젝트를 위한 폴더를 생성하고 해당 폴더로 이동합니다. Docker Compose는 기본적으로 현재 폴더의 이름을 프로젝트명으로 사용합니다.

   mkdir step1
   cd step1

  2. `docker-compose.yml` 파일 작성

  step1 폴더 안에 다음과 같이 docker-compose.yml 파일을 작성합니다.

vi docker-compose.yml

# Compose 파일 버전
version: '3.8'

# 서비스(컨테이너) 목록 정의
services:
  # 'web' 서비스 정의
  web:
    image: httpd
    ports:
      - "80:80"
    links:
      - mysql:db
    # depends_on: mysql 서비스가 시작된 후에 web 서비스를 시작하도록 의존성 설정
    depends_on:
      - mysql
  
  # 'mysql' 서비스 정의
  mysql:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: 1004

  > 컨테이너 이름 규칙
  > container_name을 따로 지정하지 않으면, Docker Compose는
  `프로젝트명_서비스명_번호` 규칙으로 컨테이너 이름을 자동 생성합니다. 
  (예: step1_web_1, step1_mysql_1)

  3. Docker Compose 실행 및 종료
    * docker-compose : v1 명령어 
    * docker compose : v2 명령어 

  docker compose up -d 파일이 있는 위치에서 아래 명령어를 실행합니다.

   * 포그라운드(Foreground)로 실행 : 컨테이너의 로그가 현재 터미널에 실시간으로 출력됩니다. Ctrl + C를 누르면 종료됩니다.
   
     docker compose up

   * 백그라운드(Background)로 실행 : -d (detached) 옵션을 사용하여 컨테이너를 백그라운드에서 실행합니다.

     docker compose up -d

   * 실행 종료 및 자원 정리 : up으로 생성된 컨테이너, 네트워크 등을 모두 중지하고 제거합니다.
     docker compose down

  2.2. 특정 파일 및 컨테이너 이름 지정

  1. `docker compose up -d2.yml` 파일 작성

  이번에는 container_name 속성을 추가하여 컨테이너 이름을 직접 지정해
  보겠습니다.

# vi docker compose up -d2.yml

version: '3.8'
services:
  web:
    image: httpd
    container_name: web  # 컨테이너 이름을 'web'으로 명시적으로 설정
    ports:
      - "80:80"
    links:
      - mysql:db
    depends_on:
      - mysql

  mysql:
    image: mysql
    container_name: mysql # 컨테이너 이름을 'mysql'으로 명시적으로 설정
    environment:
      MYSQL_ROOT_PASSWORD: 1004

  2. 특정 Compose 파일 실행 및 종료

  docker compose up -d.yml이 아닌 다른 이름의 파일을 사용하려면 -f 옵션으로 파일
  경로를 지정해야 합니다.

   * 포그라운드로 실행 :
     docker compose -f docker compose up -d2.yml up

   * 백그라운드로 실행:
     docker compose -f docker compose up -d2.yml up -d

   * 실행 종료 및 자원 정리:
     docker compose -f docker compose up -d2.yml down

3. Docker Compose 예제: 웹 페이지 방문 횟수 카운터 예제

  간단한 Python 웹 애플리케이션(Flask)과 데이터베이스(Redis)를 Docker Compose로
  구성하는 예제를 만들어 보겠습니다.

   * web: 사용자가 접속하는 웹 애플리케이션입니다. 접속할 때마다 Redis
     데이터베이스의 숫자를 1씩 올리고, 현재 숫자를 화면에 보여줍니다.
   * redis: 방문 횟수를 저장하는 간단한 Key-Value 데이터베이스입니다.

  파일 설명

  visit-counter 디렉토리 안에 다음과 같은 파일들을 생성했습니다.

  1. app.py - 웹 애플리케이션 코드

from fastapi import FastAPI
from redis import Redis

app = FastAPI()
# 'redis'는 docker compose up -d.yml에 정의된 서비스 이름입니다.
# Docker 내부 네트워크에서 이 이름으로 Redis 데이터베이스에 접속할 수 있습니다.
redis = Redis(host='redis', port=6379)

@app.get("/")
def read_root():
    # 'hits'라는 키의 값을 1 증가시킵니다. 키가 없으면 새로 만듭니다.
    count = redis.incr('hits')
    return {"message": f"이 페이지는 {count}번 방문되었습니다."}

   * FastAPI를 사용하여 간단한 웹 서버를 만듭니다.
   * redis = Redis(host='redis', port=6379): Redis 데이터베이스에 연결합니다. 여기서 host는
     docker compose up -d.yml 파일에 정의된 redis 서비스의 이름입니다. Docker Compose는 서비스 이름으로 컨테이너
     간 통신을 할 수 있도록 네트워크를 자동으로 설정해 줍니다.
   * @app.get("/"): 웹 브라우저에서 루트 경로 (/)로 접속했을 때 read_root 함수가 실행됩니다.
   * redis.incr('hits'): Redis에 hits라는 이름의 키(key)를 찾아 그 값을 1 증가시킵니다. 만약 hits 키가
     없다면 1로 초기화합니다.
   * 증가된 숫자를 포함한 메시지를 JSON 형태로 반환합니다.

  2. requirements.txt - Python 패키지 목록

   1 fastapi
   2 uvicorn
   3 redis

   * app.py를 실행하는 데 필요한 Python 라이브러리 목록입니다.
   * fastapi: 웹 프레임워크
   * uvicorn: FastAPI를 실행하기 위한 웹 서버
   * redis: Python에서 Redis를 사용하기 위한 클라이언트 라이브러리

  3. Dockerfile - web 서비스의 설계도

# 베이스 이미지로 Python 3.9 slim 버전을 사용합니다.
FROM python:3.9-slim

# 컨테이너 안에서 작업할 디렉토리를 /app으로 설정합니다.
WORKDIR /app

# requirements.txt 파일을 컨테이너의 /app 디렉토리로 복사합니다.
COPY requirements.txt .

# 복사한 requirements.txt를 이용해 패키지를 설치합니다.
RUN pip install --no-cache-dir -r requirements.txt

# 현재 디렉토리의 모든 파일을 컨테이너의 /app 디렉토리로 복사합니다.
COPY . .

# 컨테이너가 시작될 때 실행할 명령어를 지정합니다.
# uvicorn 서버를 0.0.0.0:80에서 실행합니다.
CMD ["uvicorn", "app:app", "--host", "0.0.0.0", "--port", "80"]

   * 이 파일은 web 서비스의 Docker 이미지를 어떻게 만들지 정의하는 설계도입니다.
   * Python 3.9 이미지를 기반으로, 소스 코드를 복사하고 requirements.txt에 명시된 라이브러리들을 설치합니다.
   * 마지막으로 uvicorn을 사용해 FastAPI 애플리케이션을 실행하도록 설정합니다. --host 0.0.0.0은 컨테이너
     외부에서도 접속을 허용하도록 하는 설정입니다.

  4. docker compose up -d.yml - 다중 컨테이너 실행 설정

services:
  web:
    # 현재 디렉토리의 Dockerfile을 사용하여 이미지를 빌드합니다.
    build: .
    # 호스트의 8000번 포트와 컨테이너의 80번 포트를 연결합니다.
    ports:
      - "8000:80"
    # redis 서비스가 시작된 후에 web 서비스를 시작합니다.
    depends_on:
      - redis

  redis:
    # Docker Hub에 있는 공식 Redis 이미지를 사용합니다.
    image: "redis:alpine"

   * 이 파일은 여러 개의 컨테이너를 한 번에 관리하기 위한 설정 파일입니다.
   * services: 실행할 컨테이너들을 정의합니다.
       * web:
           * build: .: 현재 디렉토리의 Dockerfile을 사용해 이미지를 직접 빌드합니다.
           * ports: - "8000:80": 내 컴퓨터(호스트)의 8000번 포트로 들어오는 요청을 컨테이너의 80번 포트로
             전달합니다. 그래서 우리는 localhost:8000으로 접속할 수 있습니다.
           * depends_on: - redis: web 컨테이너를 실행하기 전에 redis 컨테이너를 먼저 실행하도록 순서를
             정해줍니다.
       * redis:
           * image: "redis:alpine": Docker Hub에서 redis:alpine 이미지를 다운로드하여 컨테이너를 실행합니다.
             alpine 버전은 용량이 작은 경량화 버전입니다.

  실행 방법

   1. 터미널을 엽니다.

   2. 프로젝트 디렉토리 생성 후 이동합니다.
     mkdir ~/visit-counter && cd ~/visit-counter

   3. Docker Compose를 사용하여 애플리케이션을 실행합니다.
     docker compose up -d up -d
       * 이 명령어를 실행하면 Docker가 docker compose up -d.yml 파일을 읽어 web 서비스의 이미지를 빌드하고, web과
         redis 두 개의 컨테이너를 백그라운드에서 실행합니다. (-d 옵션)
       * 처음 실행할 때는 이미지를 빌드하고 다운로드하느라 시간이 조금 걸릴 수 있습니다.

   4. 웹 브라우저 또는 curl을 사용하여 확인합니다.
       * 주소창에 http://hostip:8000을 입력하고 접속합니다.
       * {"message":"이 페이지는 1번 방문되었습니다."} 와 같은 메시지가 보일 것입니다.
       * 페이지를 새로고침할 때마다 숫자가 1씩 증가하는 것을 확인할 수 있습니다.
       * curl http://localhost:8000

  종료 방법

  애플리케이션을 중지하고 컨테이너를 삭제하려면 다음 명령어를 실행합니다.

  docker compose up -d down
  이 명령어를 실행하면 생성되었던 컨테이너와 네트워크가 모두 삭제됩니다. (단, Redis 데이터는 삭제되지 않을
  수 있습니다. 데이터를 완전히 삭제하려면 docker compose up -d down -v 옵션을 사용해야 합니다.)
  

  4. 주요 Docker Compose 명령어

   * `docker compose up -d up`: 컨테이너를 생성하고 시작합니다(포그라운드 실행).
   * `docker compose up -d up -d`: 컨테이너를 백그라운드에서 생성하고 시작합니다.
   * `docker compose up -d down`: 컨테이너를 중지하고 삭제합니다. (-v 옵션을 추가하면
     볼륨도 함께 삭제)
   * `docker compose up -d ps`: 실행 중인 컨테이너 목록을 보여줍니다.
   * `docker compose up -d logs`: 서비스의 로그를 출력합니다. (예: docker compose up -d
     logs web)
   * `docker compose up -d build`: 서비스를 다시 빌드합니다. (예: docker compose up -d
     build web)
   * `docker compose up -d exec <서비스이름> <명령어>`: 실행 중인 컨테이너에 명령어를
     실행합니다. (예: docker compose up -d exec web bash)

  이 예제를 통해 Docker Compose의 기본적인 개념과 강력함을 이해하셨기를
  바랍니다. 이제 직접 다양한 서비스를 조합하여 복잡한 애플리케이션도 손쉽게
  관리해보세요.


4. docker compose 수정된 서비스만 다시 빌드하여 실행 하는 예제

  Docker Compose의 빌드 및 재시작 원리

  Docker Compose는 매우 효율적으로 작동합니다. docker compose up -d up 명령을 실행할
  때, Compose는 각 서비스에 대해 다음과 같은 과정을 거칩니다.

   1. 이미지 확인: 서비스에 연결된 Docker 이미지의 해시(ID)를 확인합니다.
   2. 컨테이너 확인: 현재 실행 중인 컨테이너가 사용하는 이미지의 해시와
      1번에서 확인한 이미지의 해시를 비교합니다.
   3. 재시작 결정:
       * 두 해시가 동일하면, 코드가 변경되었더라도 이미지 자체가 바뀌지
         않았으므로 기존 컨테이너를 그대로 사용합니다. (이것이 `up`만으로는
         코드 변경이 반영되지 않는 이유입니다.)
       * 두 해시가 다르면, 기존 컨테이너를 중지/삭제하고 새 이미지로 컨테이너를
         다시 생성합니다.

  따라서 수정된 서비스만 다시 실행하는 핵심은 "해당 서비스의 이미지를 새로
  빌드하여 이미지 해시를 변경하는 것" 입니다.

  수정된 서비스만 다시 빌드하고 실행하는 방법 (Workflow)

  가장 일반적이고 효율적인 워크플로우는 다음과 같습니다.

   1. 코드 수정: 서비스의 소스 코드를 수정합니다. (예: app.py 파일 수정)
   2. 특정 서비스 빌드: docker compose up -d build <서비스이름> 명령으로 변경된
      서비스의 이미지만 다시 빌드합니다.
   3. 컨테이너 재시작: docker compose up -d 명령으로 전체 스택을 다시
      시작합니다. 이때 Compose는 이미지가 변경된 서비스의 컨테이너만 새로
      생성하고, 변경 없는 서비스의 컨테이너는 그대로 둡니다.

  웹 애플리케이션 문구 수정하기

  이전 예제에서 app.py의 환영 메시지를 변경하고, web 서비스만 다시 빌드하여
  적용해 보겠습니다.

  1단계: 기존 코드 복사 후 작업 폴더로 이동합니다 
    cp -r ~/visit-counter visit-counter2 && cd ~/visit-counter2 
  
  2 다시 실행

   docker compose up -d

   * 이 명령은 web 이미지를 빌드하고, redis 이미지를 다운로드한 후 두 개의
     컨테이너를 백그라운드에서 실행합니다.
   * 웹 브라우저에서 http://localhost:8001 로 접속하면 "Welcome! You are
     visitor number 1." 이라는 수정된 메시지가 보입니다.

  2. 코드 추가 수정

  이제 app.py 파일의 메시지를 다시 한번 수정해 보겠습니다.

   vi app.py' 파일
   @app.route('/')
   def hello():
       count = redis.incr('hits')
       # --- 메시지 다시 수정 ---
       return f'This is a modified page! Visitor: {count}.\\n'

  3. 변경 사항 확인 (아무것도 안 바뀜)

  만약 여기서 docker compose up -d 를 다시 실행하면 어떻게 될까요?

    docker compose up -d 

   * 결과: 터미널에 redis is up-to-date, web is up-to-date 라는 메시지만
     표시되고 아무런 변화가 없습니다.
   * 이유: app.py 파일은 바뀌었지만, web 서비스가 사용하는 Docker 이미지는
     변경되지 않았기 때문입니다. Compose는 이미지가 동일하므로 컨테이너를
     재시작할 필요가 없다고 판단합니다.

  4. 수정된 서비스만 다시 빌드하기

  이제 web 서비스의 이미지를 새로 빌드하여 변경 사항을 반영합니다.

   docker compose build web

   * 결과:
       * 터미널에 Building web 이라는 메시지와 함께 Dockerfile의 빌드 과정이
         다시 실행됩니다.
       * COPY . . 단계에서 수정된 app.py 파일이 이미지 안으로 복사됩니다.
       * 빌드가 완료되면 새로운 해시(ID)를 가진 modified_web 이미지가
         생성됩니다.
       * redis 서비스는 build 항목이 없으므로 이 과정에서 완전히 무시됩니다.

  5. 컨테이너 재시작 및 변경 확인

  마지막으로, up 명령을 실행하여 변경된 이미지를 사용하는 새 컨테이너를 시작합니다.

   docker compose up -d 

   * 결과:
       * Compose는 redis 서비스의 이미지는 변경되지 않았으므로 redis is
         up-to-date 메시지를 출력하고 redis 컨테이너는 그대로 둡니다.
       * web 서비스의 이미지는 새로 빌드되어 해시가 변경되었으므로, 기존 web
         컨테이너를 중지/삭제하고 새 이미지로 컨테이너를 다시 생성(Recreating
         modified_web_1 ... done)합니다.
   * 확인:
       * 다시 웹 브라우저에서 http://localhost:8001 로 접속하여 새로고침 해보세요.
       * "This is a modified page! Visitor: 2." 와 같이 최종 수정된 메시지가
         표시되는 것을 확인할 수 있습니다. redis 컨테이너는 그대로
         유지되었으므로 카운터 숫자는 계속 이어서 올라갑니다.

  요약: 가장 효율적인 워크플로우

   1. 코드 수정: app.py 등 소스 코드 변경
   2. `docker compose build <서비스이름>`: 변경된 서비스만 지정하여 이미지 리빌드
   3. `docker compose up -d up -d`: 컨테이너 재시작 (Compose가 알아서 변경된 서비스만 교체)

  이 방법을 사용하면 불필요한 빌드나 컨테이너 재시작을 피할 수 있어, 특히
  규모가 큰 애플리케이션에서 개발 및 테스트 시간을 크게 단축할 수 있습니다.

